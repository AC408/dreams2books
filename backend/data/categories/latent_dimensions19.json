[
    {
        "Title": "data structures and algorithms with objectoriented design patterns in c",
        "description": "Create sound software designs with data structures that use modern object-oriented design patterns! Author Bruno Preiss presents the fundamentals of data structures and algorithms from a modern, object-oriented perspective. The text promotes object-oriented design using Java and illustrates the use of the latest object-oriented design patterns. Virtually all the data structures are discussed in the context of a single class hierarchy. This framework clearly shows the relationships between data structures and illustrates how polymorphism and inheritance can be used effectively. Key Features of the Text * All data structures are presented using a common framework. This shows the relationship between the data structures and how they are implemented. * Object-oriented design patterns are used to demonstrate how a good design fits together and transcends the problem at hand. * A single Java software design is used throughout the text to provide a better understanding of the operation of complicated data structures. * Just-in-time presentation of mathematical analysis techniques introduces students to mathematical concepts as needed. Visit the Text's Web Site A comprehensive web site is available for users of the text at www.wiley.com/college/preiss. The site includes: * The Web Book (a hypertext version of the complete book) * Links to the Java Source Code (all the program examples from the text) * Opus5 Package (a Java package comprised of all the source code from the text) * Documentation (source code documentation) * Demo Applets (various Java applets that illustrate data structures and algorithms from the text) * Archive (JAR format archive of the source code from the text) * Front Matter (table of contents and preface) * Solutions Manual (password required) * Errata",
        "authors": "['Bruno R. Preiss']",
        "infoLink": "http://books.google.nl/books?id=ywpRAAAAMAAJ&dq=Data+Structures+and+Algorithms+with+Object-Oriented+Design+Patterns+in+C&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "Believe the summary...this book is for 2nd and 3rd year post-secondary students. I am an experienced C++ programmer, but Grade 12 math isn't enough to cut through the explanations to get to the code, which I can understand perfectly well.Who should buy this book? Students with a good grasp of basic calculus, who want a thoroughly academic treatment of algorithms in C++ in order to pass Computer Science.Who should not? A C++ programmer that wants clear, effectively presented information on implementing standard algorithms and data structures in order to get their project done.I'm of the Keep It Simple school of thought, and the practical theory and implementations in this book could have been presented much more effectively without the adademic bafflegab.I am currently working on my calculus skills in my spare time, and as my familiarity with the mathematical notation grows, I may be able to put this book to good use. Untill then I wish I'd bought something else, programming doesn't need to be as dense as this book makes it.",
                "review/helpfulness": "29/32",
                "num_reviews": 32
            },
            {
                "review/text": "The book has a detailed introduction and explanation to the subject and clearly explains how to analyze and implement in programming. This is done all in C++ and it is suited to students in Computer Science Courses. The exercises at the end of the chapters are quite useful.",
                "review/helpfulness": "15/20",
                "num_reviews": 20
            },
            {
                "review/text": "I think I said it all right there. Great for intermediate/advanced c++ users. It also contains sections on various algorithms which implement many of the data structures discussed in previous chapters. Just get the book already!",
                "review/helpfulness": "12/16",
                "num_reviews": 16
            },
            {
                "review/text": "This is a great book for one who has had a formal study of undergraduate Calculus/Algebra and a very good understanding of the C++ language. The book starts off with explaining the fundamentals that will be applied to measure the effectiveness of a piece of code, and is very helpful for those who wants to understand the basic theory applied in the later chapters. This books treats almost all the basic data structures and have been presented in a very simple non-profounding way, like keeping the class design and hiearchy the same throughout. All the data structures have been explained using the (easy to use) arrays as well as link-lists. This makes it easier for a novice to grasp the fundamentals and go on to implement more complex and effective data structures using link lists. Overall, I found this book extremely helpful in getting a sound footing on this topic.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            }
        ]
    },
    {
        "Title": "eclipse rich client platform designing coding and packaging java applications",
        "description": "Written by the leaders of the Eclipse RCP project, this is the first and ONLY book on Eclipse Rich Client Platform!",
        "authors": "['Jeff McAffer', 'Jean-Michel Lemieux']",
        "infoLink": "http://books.google.com/books?id=LjYYngEACAAJ&dq=Eclipse+Rich+Client+Platform:+Designing,+Coding,+and+Packaging+Java+Applications&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This is really an awesome book because:* I was suprised how extremely complete this book is. It not only explain how to develop a application, but also how you do your HELP-system, the plugin update mechanism, dynamic plugins, brand and package your application. Also chapter 25 called 'The last mile' explain Native Installers, Webstart and multi user install scenario. SO:it explains the whole cycle, for creating windows/views, creating the help, and distributing the application!* It offers a tutorial for building a real world application what the authors have called Hyperbola (a Chat client). This tutorial has a good level, compared to books like '... for dummies', '... in 24 hours' and '... unleashed'.* The tutorial application EVOLVES over the chapters. So after the end of every chapter the application is running, and more (complex) functionality is added every chapter. So you don't need to follow all chapters before you see results of your work (it's not a big bang application). This keep you motivated to follow the book and play arround.Or how the authors call it in the book:\"The next few chapters focus on iteratively developing Hyperbola. This next interation is interesting because it allows you to quickly get something running you can show to your mom, your boss, or your friends. It's also a lot more fun to learn RCP while developing something concrete.\"* Every chapter starts with the goals of this chapter,e.g. what you will add to the application in this chapter.* This book does NOT contains cheap fillers (some books repeat things endless, starts with chapters introducing Java, prints the Java Doc of a library,etc.). It is simply to the point.* The tutorial is very complete and contains a lot of explaination about what you're doing. It is not one big listing. E.g. it explain what Actions are, what you can do with it, where to code them, and of course how to code them in your Hyperbola application.* It is very complete because it e.g. starts how to install Eclipse and the Eclipse RCP SDK and how you need to configure them. This is a real timesaver for novice Eclipse people. You just need to follow the steps in the introduction chapter.So this is a learning-by-doing book with a good level. After you have read this book (and played with Eclipse), you are able to develop simple RCP-applications, you know how the RCP is structured, how to package them, etc.",
                "review/helpfulness": "44/46",
                "num_reviews": 46
            },
            {
                "review/text": "I bought this book almost the first day it became available, I think in November of last year, and loved it, despite numerous minor errata which I submitted but have not been published. It explains the structure of the RCP very well, as well as I have seen anywhere. Parts I, III, IV and V are excellent.This is a great introduction to Eclipse RCP ... _IF_ you are happy to stay with Eclipse 3.1 and Java 1.4. _BUT_ sadly, Eclipse 3.2 has obsoleted some of the techniques used in Part II, the tutorial, which is the main part of the book. For in 3.2 example you no longer need to create a target manually yourself. Also the tutorial's code uses APIs that are deprecated in Eclipse 3.2, and it uses code seen as undesirable by Java 1.5's generics support. In addition Eclipse 3.2 mandates the com.ibm.icu (International Components for Unicode) package which means that the tutorial as delivered simply will not deploy as-is when you get to the packaged product level in Chapter 9.Yes, all these problems are fixable. But be careful because you will have to fix these problems manually, which cuts you off from the cool \"Samples Manager\" tool which synchronizes your code at the end of each chapter.",
                "review/helpfulness": "35/38",
                "num_reviews": 38
            },
            {
                "review/text": "Good book, except..., the code samples are embedded in a plugin that only works with Eclipse 3.1. I tried 3 times on Mac OS X to load the code samples some way, including the book's website, and disaster happens. Not only does the code not show up, but all my closed Eclipse projects opened up, and my entire Eclipse 3.2 crashed big time... I was doing fine going through the tutorial, Hyperbola ( a chat room app), and then the book gets to the point where it forces you to install the code samples from their website. You are stuck if you have Eclipse 3.2 running.",
                "review/helpfulness": "18/21",
                "num_reviews": 21
            },
            {
                "review/text": "This book starts out in a very promising manner - coming in from a 10,000 ft view to a 1,000 ft view. After reading Part I, I felt that I had a great book in my hands. With Part II however came the big let down: you're suddenly dropped into a chaotic sea of microscopic views. With its (basically laudable) approach by example, it turns essentially into a collection of recipes, that does very little to the understanding of the underlying structure and concepts of RCP. This is probably a great book if you know what you want to do and why, it is however inadequate if you are in search of the why. It leaves too many loose ends, and in numerous instances assumes that you have fully absorbed the superficial ideas of earlier sections and hence leaves you hanging there. Calling the CD to the rescue - again a great idea how it is integrated - does not always help: for instance Chapter 10 seems to be totally messed up. The text and examples contain a number of misleading typos or omissions, and references are given to Eclipse code that I could not find.In hindsight I sense that much of the frustration with Part II could be avoided by starting with Parts III and IV: after working through these latter parts, I felt more at ease filling out the unfortunate and time consuming gaps in Part II.I suspect also that both the code and the book will need to be updated for release 3.2.",
                "review/helpfulness": "16/17",
                "num_reviews": 17
            },
            {
                "review/text": "Having read \"Eclipse RCP\" in its entirety as a manuscript reviewer, I can tell you that this is a superb book. The authors have done a splendid job of creating a technical book that serves well as both a tutorial and as a reference.Through the development of a single example, the book covers everything you need to get started building and packaging an Eclipse RCP application. The book even includes a CD containing all the software you'll need to work through the tutorials and build your own RCP applications.While a single book could never describe every aspect of the Eclipse Platform, this book is certainly all you need to get started with Eclipse RCP, and then once you've found your feet, there are other books in the Eclipse Series that will help expand your knowledge of the Eclipse Platform and Eclipse plug-in development.This book has been produced extremely well: The text is well written, the pages are full of easy to follow code snippets, and there are sidebars that share best practices and handy tips, as well as plenty of good quality screen shots and diagrams.Buy this book. Read this book. You'll be glad you did.",
                "review/helpfulness": "12/15",
                "num_reviews": 15
            },
            {
                "review/text": "I wanted to start off by saying what a treat it has been to use McAffer and Lemieux's book. It is well written and easy to comprehend. The chapters follow a logical sequence and I particularly like the way that \"Notes\" and \"Tips\" clarify and support the rest of the material.My team is in the later stages of implementing a Rich Client product, and \"Eclipse Rich Client Platform\" has helped us with both small details and broad concepts. We referenced it extensively when creating and debugging an automated build (Chapter 24), adding Update Actions to our product (Chapter 14) and Reporting Status (Chapter 17). Although we took the \"tossed salad\" approach to using the book it also works very well as a step by step tutorial. You don't need to be a Java guru or Eclipse expert to understand the book, yet it is still useful for the relative beginner.The last time I wrote in praise of a book, it was to JRR Tolkien for Lord of the Rings. I distribute my praise sparingly and this book deserves it.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "After I wrote the following review and worked with some other documents, I returned this book and worked again with the example on page 52. And I suddenly guessed that the code was not obsolete but erroneous. (Examining RCP reference I found IPlatformRunnable.run() was replaced with IApplication.start() but they wrote IApplication.run() instead and completely forgot to implement IApplication.stop() ) I looked around for an errata. Found here: [...]. And I've decided to read this book again with errata. So I change my rating to 3 stars. I'll not give them 4 or 5 stars; because their sloppy work cost my valuable time. They had enough time for an error-free version before the 2nd edition.for ERRATA: [...]MY OLD COMMENT for 1 star.Even the authors promise to follow Galileo (Eclipse 3.5) release, the book does not follow Galileo. The very first class of the RCP example project Hyberbola, namely the Application class, implements IApplication.run() which is obsolete. New release should implement start() and stop() methods instead. The screen shots of wizard dialogs in this book, does not follow the actual wizard dialogs of Galileo. Appreantly the authors were too lazy to update this long awaited 2nd release, and the editors were sleepless during corector readings.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "Don't buy this book unless you are an experienced Java coder, who knows Eclipse, and has the time and inclination to debug.The book walks you through building a single instant messaging app. Each chapter is a step, with example code downloadable in Eclipse via the authors' Samples Manager.Beyond Ch 8, their examples have bugs, either in the code itself or the configuration files, or the instructions in the text.Some are trivial, such as in Ch 9 not telling you that you must un-check \"Generate a metadata repository\" in the Export Wizard or no executable is generated.Some are huge, such as their sourcecode for Ch 16-17 using a different version IM library than earlier or later chapters. This results in compile errors until you manually debug the code.Some are just irritating, as their Ch 12 sample code not including the login code developed in the previous chapter. This causes a NullPointerException in ContactsView.Or their Ch 16 drag-and-drop that doesn't drop until you manuallly make extension point IDs match.Operationally, their IM example relies on a server at their book site.Over the several weeks I was using their book, their server was down. Fortunately, our company has an accessble XMPP server, else I could not have run their examples.And fortunately folks on the book's forum were helpful.So with some debugging, I was able to run most of their examples.DO buy this book if the above don't trouble you.Their example is broken into manageable chunks. There appear to be no major gaps in their progression. Their example code is clear and concise, if buggy. And their writing is clear, concise, and complete.Also, their book thoroughly covers plug-in management and updating, and the use of OSGi.For more on this saga, go to the book's Web site, [...], and look at the forum entries.Would I buy this book again? Yes; I learned a lot from it. But I've been coding for $$ for 30 years and like debugging.",
                "review/helpfulness": "7/7",
                "num_reviews": 7
            },
            {
                "review/text": "I bought this book because online references for this material are woefully inadequate and just plain outdated. Every resource I could find said this is THE BOOK to get to get a thorough walk-through on the technology. I bit and shelled out the $$$ for the book. The first few chapters are okay, if not really engaging. They give an \"okay\" review of the platform and how it works, if you can overlook them constantly tooting their own horn about how great the Eclipse IDE is (the application that led to the development of the Eclipse RCP).I was looking forward to building the application the book uses to teach the technology, an instant message client they call \"Hyperbole\". I figured once we started development, things would get exciting.The problems began in Chapter 3. The walkthrough of how to create a \"Target platform\" bore no resemblance to what needed to be done in the IDE. I knew that the IDE had gone through a version or two since this book was published--only in May, for crying out loud--so I tried to struggle through. It was hopeless. There is no way to resolve what was described in the book with what the IDE contains.Skipping that, since it was optional anyway, I sallied forth to the following chapters. Resolving the differences between the current version of the IDE and what the book contained was still troublesome, but I was able to figure out what the author(s) meant and create the initial application. I actually got the application running, but then it all fell apart in Chapter 5. One of the first tasks is to create a \"View\". I was able to add the view as described in the book, but it failed to show in the application. Debugging it was fruitless since the platform changes the fundamentals of how applications operate.Either the platform totally changed or the book is wrong. Checking the online errata was fruitless: the book does have some errata, but nothing addresses this problem. And that's where it stands. I unable (and unwilling) to progress any more through this this book simply because it's too frustrating.But I'm not the only one who found this technology (and book) frustrating: several co-workers met with the same problems and are confounded by the unreliable information on the Internet about this technology. Either this book needs to be updated for the numerous changes in the IDE, or RCP needs to settle down and stop changing so much, or both.I DO NOT recommend this book as a guide for the Eclipse RCP, despite the fact it is hailed as THE BIBLE of this technology.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "Eclipse Rich Client Platform is an excellent book for both introduction to Eclipse RCP, and for the more experienced programmer.They take a tutorial approach to introducing Eclipse RCP, and describe the building of an Instant Messaging client as an RCP application. This works very well, as it allows the reader to connect their own application-level needs to the mechanisms that RCP provides.Then they shift gears and discuss user interface concepts like the Workbench, Perspectives, Views, Editors, Actions, etc more abstractly, so that the reader can get a very thorough understanding of the main patterns and concepts in the APIs available to Eclipse RCP client applications. Finally they discuss development and deployment processes made possible by the basic plugin model, the update mechanisms, and product configurations.The authors do an excellent job of making RCP accessible for the uninitiated, while still presenting plenty of details for the more experienced RCP developer.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            }
        ]
    },
    {
        "Title": "practical genetic algorithms",
        "description": "* This book deals with the fundamentals of genetic algorithms and their applications in a variety of different areas of engineering and science * Most significant update to the second edition is the MATLAB codes that accompany the text * Provides a thorough discussion of hybrid genetic algorithms * Features more examples than first edition",
        "authors": "['Randy L. Haupt', 'Sue Ellen Haupt']",
        "infoLink": "https://play.google.com/store/books/details?id=k0jFfsmbtZIC&source=gbs_api",
        "review": [
            {
                "review/text": "From the word &quot;practical&quot; in the title, I expected more concrete examples of software source code. There are no such examples in this book. In particular, Appendix A starts with, &quot;We don't provide computer code in this book&quot;. (Thanks for waiting until Appendix A to tell me!)Otherwise, the book is well written and an easy read. It's just more theoretical and abstract than I expected.",
                "review/helpfulness": "31/40",
                "num_reviews": 40
            },
            {
                "review/text": "Presents non-standard techniques without pointing out the standard ones. The non-standard techniques were recommended strongly based only on author's personal opinions, without comparison to other standard techniques on broad spectrum.For starters, it is much better to look into &quot;An Introduction to Genetic Algorithms&quot; by Melanie Michell.",
                "review/helpfulness": "20/23",
                "num_reviews": 23
            },
            {
                "review/text": "This book is a good one for beginning GA programmers to start with. It provides sufficient detail for implementing both binary and continuous GAs, and compares their performance throughout the book. The applications described are diverse and interesting, although some of the engineering applications were hard for me to follow. In short, I found this book interesting and full of good ideas to experiment with.",
                "review/helpfulness": "18/18",
                "num_reviews": 18
            },
            {
                "review/text": "Before I read this book, I had heard about GA and had an idea about how it works, but had no clue to actually coding it. One day I bought this book and spent a day to read it. On the following day, I was able to write my own GA driver code!",
                "review/helpfulness": "11/15",
                "num_reviews": 15
            },
            {
                "review/text": "I found this book to be an extremely clear and easy to understand introduction to genetic algorithms. It was particularly helpful to see examples of both binary and continuous versions of genetic algorithms, and to see explanations of examples on both elementary and advanced levels. This is a good book to read before buying one of the more comprehensive, rigorous technical books on the subject.",
                "review/helpfulness": "13/13",
                "num_reviews": 13
            },
            {
                "review/text": "This is a very simple introductory book to read on genetic algorithm. It provides a good overview of the main mechanisms involved. There is no theoretical treatment of the subject. The Pesudcodes provided in the appendixes have some mistakes. I recommend it for people who want quick general outline of what genetic algorithms means and how to apply it.",
                "review/helpfulness": "10/11",
                "num_reviews": 11
            },
            {
                "review/text": "This book is well written, with good examples and insights. However, I think that there should be many more examples and theory to warrent the price of this book. Therefore, better take this book from a library or wait for a softcover.",
                "review/helpfulness": "8/10",
                "num_reviews": 10
            },
            {
                "review/text": "In my opinion to well understand a process/method you have to follow an example in every little detail. This book does exactly this and once read allows to write your own code easily. I highly recommend this book!",
                "review/helpfulness": "7/7",
                "num_reviews": 7
            },
            {
                "review/text": "This is a really good 'hands on' introduction to genetic algorithms. Mitchell gives a great introduction as well, but this book gets into the 'practical' side of it.Haupt^2's book starts off with an introduction. The ideas behind optimization are covered briefly (~20pgs). The book then proceeds into the ideas behind binary genetics (also introducing the evolutionary ideas ~25 pgs). The book then goes into developing the code itself, while describing the trade offs. Very good examples under applications are given (both basic and advanced ~40pgs). More sophisticated techniques are developed, with a wrap up on current trends in GA.A great intro book (undergrad *even high school*), and a friend to the working scientist/engineer. This is a book that'll help get the job done.",
                "review/helpfulness": "6/6",
                "num_reviews": 6
            },
            {
                "review/text": "Based on the literature I have explored, I can unequivocally say that this is the best book that I have found on GA theory and programming.In a simple but effective manner, the book explains the intricate concepts. For any one thinking of learning GA theory this is a good starting point. Also, if you want to write programs to create your own genetic algorithms, this is a must-read.In my humble opinion, this is 'THE BEST' book particularly for those without much GA experience.I hereby express my heartfelt gratitude to the authors and congratulate them on their effort.",
                "review/helpfulness": "3/4",
                "num_reviews": 4
            }
        ]
    },
    {
        "Title": "modern compiler implementation in ml",
        "description": "This new, expanded textbook describes all phases of a modern compiler: lexical analysis, parsing, abstract syntax, semantic actions, intermediate representations, instruction selection via tree matching, dataflow analysis, graph-coloring register allocation, and runtime systems. It includes good coverage of current techniques in code generation and register allocation, as well as functional and object-oriented languages, that are missing from most books. In addition, more advanced chapters are now included so that it can be used as the basis for two-semester or graduate course. The most accepted and successful techniques are described in a concise way, rather than as an exhaustive catalog of every possible variant. Detailed descriptions of the interfaces between modules of a compiler are illustrated with actual C header files. The first part of the book, Fundamentals of Compilation, is suitable for a one-semester first course in compiler design. The second part, Advanced Topics, which includes the advanced chapters, covers the compilation of object-oriented and functional languages, garbage collection, loop optimizations, SSA form, loop scheduling, and optimization for cache-memory hierarchies.",
        "authors": "['Andrew W. Appel']",
        "infoLink": "https://play.google.com/store/books/details?id=VVGbAAAAQBAJ&source=gbs_api",
        "review": [
            {
                "review/text": "This book covers a remarkably broad territory of compiler issues, with a good balance of clarity and depth. It spends long enough on each topic to work through examples of functioning code, but doesn't dwell on any for so long that the reader loses interest. A decent set of variations on language design, runtime organization, and machine architecture are also discussed and implemented.An important caveat is that readers ought to know some dialect of ML. If not, this book does not teach it; there are alternative renditions of the same text in C and Java, but I have not read them. Apparently many reviewers find those confusing. The java rendition, for example, has many angry reviewers. Possibly disgruntled students who had a hard time with their coursework, possibly people with valid complaints about the text.All I can say is that I quite enjoyed it, and return to it regularly for its clear presentation, when working with related algorithms.",
                "review/helpfulness": "21/21",
                "num_reviews": 21
            },
            {
                "review/text": "This book aims at teaching the reader how to write compilers and interpreters. Compared to other books (most notably the Dragon book - Aho, Sethi &amp; Ullman: Compilers - Principles, Techniques and Tools) the structure and organization of the compiler he teaches are better and more in sync with modern compiler research. So although ML is not a language that is used much in practice it is well choosen for teaching compilers.The first part of the book is intended for undergraduate Computer Science university student and the second part is for graduate students. I have only read the first part and browsed the second part. The first part is founded on the development of a compiler - the Tiger compiler - and that is the main flaw of the book. The Tiger compiler is fairly advanced and it is built up one phase at the time (see the chapter headings in the synopsis). A undergraduate reader who has never read anything about compiler design before will be very confused. The book is good in the way that it presents many good compiler design ideas and I learned some from it, but for me it was not the first book on compiler. I just think that the first part of the book has too steep a learning curve - even if you are proficient with ML, which is an absolute must. Recommended for serious readers who already know something about compiler construction before reading it. For other people I recommend the older but somewhat outdated book: Aho, Sethi &amp; Ullman: Compilers - Principles, Techniques and Tools.",
                "review/helpfulness": "17/20",
                "num_reviews": 20
            },
            {
                "review/text": "Appel explains the structure of a compiler in a very clear and precise fashion, including a lot of quite modern techniques. *However* it is only clear and precise if you have a rough high-level understanding of compilers and a good knowledge of ML beforehand. (If you understand one of the two, it is an excellent book for learning the other but you will need to do some thinking for yourself.)If you're looking to learn about compilers from the very beginning, buy something else (I liked &quot;Crafting A Compiler&quot; as a starting point). If you're wanting to get a lot more precise about the way you build compilers, buy this book.",
                "review/helpfulness": "14/15",
                "num_reviews": 15
            },
            {
                "review/text": "Appel very clearly describes, step by step, the implementation of a compiler, and explains as well the reasons why ML is a good language to use. If you don't like ML (which is, incidentally, a &quot;real language&quot;), there are Java and C versions of the book.",
                "review/helpfulness": "11/14",
                "num_reviews": 14
            },
            {
                "review/text": "I love this book. Having experimented with compiler construction for some time (though never seriously), and being a long-time ML user, Modern Compiler Implementation in ML was the perfect companion to my compiler-construction project. I largely ignored the \"Tiger\" language described in the book - I had my own ideas about what I wanted to create. Relying on the book to give you code for a whole compiler is asking far too much. The general concepts are explained, and then reinforced with sample code. I suspect the people who have complained bitterly about this book are actually just looking for a source code print out.All in all, very worthwhile. Read a chapter, try to implement the concepts, and then either re-read the same chapter, or move on.",
                "review/helpfulness": "11/11",
                "num_reviews": 11
            }
        ]
    },
    {
        "Title": "data structures and algorithms with objectoriented design patterns in java worldwide series in computer science",
        "description": "About The Book: Bruno Preiss presents readers with a modern, object-oriented perspective for looking at data structures and algorithms, clearly showing how to use polymorphism and inheritance, and including fragments from working and tested programs. The book uses a single class hierarchy as a framework to present all of the data structures. This framework clearly shows the relationships between data structures and illustrates how polymorphism and inheritance can be used effectively.",
        "authors": "['Bruno R. Preiss']",
        "infoLink": "http://books.google.com/books?id=B7UCew1VW_YC&dq=Data+Structures+and+Algorithms+with+Object-Oriented+Design+Patterns+in+Java+(Worldwide+Series+in+Computer+Science)&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "Not to bad. The book is a little high in price, but covers a large set of algorithms that could be applied to many Java applications. The book reads like a algebra book, with lots of formulas and theory and with not enough examples. Not for light reading.",
                "review/helpfulness": "9/10",
                "num_reviews": 10
            },
            {
                "review/text": "Some people are reviewing this book as hard to read, confusing, and complaining that the code doesn't compile. Such is the state of higher education these days...I would actually say that this is a very readable introductory treatment on data structures. Granted, there seems to be the occasional error in implementing classes that strictly conform to given definitions, and some of the implementations seem a bit simplistic, but overall its a fine piece of work. I found the implementations for tree traversals in chapter 9 to be rather clever.There is something of a reliance upon a hierarchy structure (introduced in ch. 5) which i think might turn some people off in using this book as a text. Chapters seem to build upon previous chapters, requiring you to read most of the book. Professors have a tendency to skip around to fit the curricula into the time of the class term which might make the book seem confusing--i've just been reading it straight through for personal amusement so i'm not as influenced by this. I think this class hierarchy is justified because the book isn't just about data structures, its also about design patterns. If you know something about either data structures or design patterns you can gain insight into both from reading this.And as for compiling the code...the purpose of books like this shouldn't be to copy and paste code. If you have even a vague understanding of the material &quot;filling in the blanks&quot; and writing your own code should be a simple matter.",
                "review/helpfulness": "8/9",
                "num_reviews": 9
            },
            {
                "review/text": "Hi, as an undergrad engineering student, I had this book for the coursebook in my algorithms course. Honestly speaking, it's good , very readable text. I never used any of the code examples fom the book in my assignments, yet they proved rather helpfull in understanding the material. Something, that I think is missing from this book is the answeres to the problems at the end of the chapter that are not programming projects. Ading them to the book could help students a lot ( no need to relay on TA's )",
                "review/helpfulness": "5/5",
                "num_reviews": 5
            },
            {
                "review/text": "The initial sections of the book focus on too much mathematical formula without providing plain English examples especially in the asymptotic analysis sections. Isn't there a book out there which explains in plain simple English? It also uses misleading terms like \"external nodes\" and \"internal nodes\" when it comes to trees. I wouldn't recommend this book. (I'm only using it because it is the university text, now I wish I had my money back)",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "linear systems",
        "description": "The sparse backslash book. Everything you wanted to know but never dared to ask about modern direct linear solvers. Chen Greif, Assistant Professor, Department of Computer Science, University of British Columbia.Overall, the book is magnificent. It fills a long-felt need for an accessible textbook on modern sparse direct methods. Its choice of scope is excellent John Gilbert, Professor, Department of Computer Science, University of California, Santa Barbara.Computational scientists often encounter problems requiring the solution of sparse systems of linear equations. Attacking these problems efficiently requires an in-depth knowledge of the underlying theory, algorithms, and data structures found in sparse matrix software libraries. Here, Davis presents the fundamentals of sparse matrix algorithms to provide the requisite background. The book includes CSparse, a concise downloadable sparse matrix package that illustrates the algorithms and theorems presented in the book and equips readers with the tools necessary to understand larger and more complex software packages.With a strong emphasis on MATLAB and the C programming language, Direct Methods for Sparse Linear Systems equips readers with the working knowledge required to use sparse solver packages and write code to interface applications to those packages. The book also explains how MATLAB performs its sparse matrix computations.Audience This invaluable book is essential to computational scientists and software developers who want to understand the theory and algorithms behind modern techniques used to solve large sparse linear systems. The book also serves as an excellent practical resource for students with an interest in combinatorial scientific computing.Preface; Chapter 1: Introduction; Chapter 2: Basic algorithms; Chapter 3: Solving triangular systems; Chapter 4: Cholesky factorization; Chapter 5: Orthogonal methods; Chapter 6: LU factorization; Chapter 7: Fill-reducing orderings; Chapter 8: Solving sparse linear systems; Chapter 9: CSparse; Chapter 10: Sparse matrices in MATLAB; Appendix: Basics of the C programming language; Bibliography; Index.",
        "authors": "['Timothy A. Davis']",
        "infoLink": "http://books.google.com/books?id=oovDyJrnr6UC&dq=Linear+Systems&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This book is definitely not well suited for use in a college engineering course. It is simply much too terse and does not present key concepts or ideas efficiently. I did myself a favor and bought Linear System Theory and Design by Chi-Tsong Chen, which is actually a surprisingly readable book. This book is not readable as a text book, I would recommend using it only as a reference.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "The Printing of the book looks as if it was made on a copy machine such that the typeface is a little fuzzy. Other than the printing, the authorship of the book is well done with many theorems and proofs. This book is recommended for graduate students or anyone in academia. Practicing engineers will find it useful only if one can understand and appreciate such rigorous theory.",
                "review/helpfulness": "5/5",
                "num_reviews": 5
            }
        ]
    },
    {
        "Title": "introduction to knowledge systems",
        "description": "Focusing on fundamental scientific and engineering issues, this book communicates the principles of building and using knowledge systems from the conceptual standpoint as well as the practical. Previous treatments of knowledge systems have focused on applications within a particular field, or on symbol-level representations, such as the use of frame and rule representations. Introduction to Knowledge Systems presents fundamentals of symbol-level representations including representations for time, space, uncertainty, and vagueness. It also compares the knowledge-level organizations for three common knowledge-intensive tasks: classification, configuration, and diagnosis. The art of building knowledge systems incorporates computer science theory, programming practice, and psychology. The scope of this book is appropriately broad, ranging from the design of hierarchical search algorithms to techniques for acquiring the task-specific knowledge needed for successful applications. Each chapter proceeds from concepts to applications, and closes with a brief tour of current research topics and open issues. Readers will come away with a solid foundation that will enable them to create real-world knowledge systems using whatever tools and programming languages are most current and appropriate.",
        "authors": "['Mark Stefik']",
        "infoLink": "https://play.google.com/store/books/details?id=SwyjBQAAQBAJ&source=gbs_api",
        "review": [
            {
                "review/text": "The author gives an exceptional and in-depth view of the topics of search, reasoning with time, space and uncertainty and also on classification. It should make a good text at the graduate-level. The book also gives excellent exercises and open- research problems. A true classic in this area. A must on the desk of every AI practitioner",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "This book is very helpful in learning about the concept of knowledge-based systems. I must caution though, that if you are familiar with artificial intelligence there is a lot of material in this book that will act as a review.When purchasing this book, I was hoping for material on developing a knowledge-based system from scratch. While it does an outstanding job in teaching you the fundamentals (clear through diagnosis and troubleshooting), it seemed to leave me slightly incomplete and in search for additional material on the subject.It's not a all-in-one book, but this is book is definitely one to consider.",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "jabber programming mt books",
        "description": "Jabber is a set of protocols expressed in XML, and an extensible framework that allows people and applications to exchange all sorts of information, from simple text messages to being used to extend the backbone of an enterprise data system. Jabber gives you the power to build applications that have identity, presence, and that can take part in conversations.Programming Jabber offers developers a chance to learn and understand the Jabber technology and protocol from an implementer's point of view. Detailed information of each part of the Jabber protocol is introduced, explained, and discussed in the form of mini-projects, or simple and extended examples. Programming Jabber provides this foundation by: Showing you how to install and configure the Jabber server Providing a detailed overview of the server architecture and configuration options Covering the core Jabber technologies such as XML streams and Jabber identifiers Referencing all of Jabber's XML namespaces Examining the client registration and authentication phases Showing how to deploy your own Jabber-based messaging solutions Demonstrating how to embed XML-RPC-style call mechanisms into Jabber Programming Jabber is divided into two parts. The first part serves as an introduction to Jabber; you'll learn about its features, why it's more than an IM system, and how to install and configure a Jabber server of your own. The second part provides detailed information about the Jabber protocol, and a series of practical examples, which can be used to solve everyday problems. The examples, in Perl, Python, and Java, use various Jabber features as a way of illustrating parts of the protocol.Programming Jabber provides the foundation and framework for developers to hit the ground running, and is the essential book on Jabber.",
        "authors": "['DJ Adams']",
        "infoLink": "https://play.google.com/store/books/details?id=tvh31VkWERUC&source=gbs_api",
        "review": [
            {
                "review/text": "Please do not be fooled by title. Less then 1/3 of the book covers Jabber programming itself. Most of book is about ... how to configure Jabber client authors developed (actually about 1/3 of book). Language is very primitive. Development environment is VB 6.0. Absolutely useless book.",
                "review/helpfulness": "32/33",
                "num_reviews": 33
            },
            {
                "review/text": "First of all, the title here is misleading. There are some snippets walking the reader through Visual Basic code, but the concepts and protocols (JEPs, XMPP, etc.) are noticeably absent. I honestly was able to read the book in a couple of hours (nothing challenging or meaty here) and found it a waste of my time. If you are having trouble installing Jabber clients, this may be a useful resource since the real focus of the book seems to be this very topic. However, the information included is also dated. Here is my recommendation: if you are looking for a decent Jabber book, start with the O'Reilly one.",
                "review/helpfulness": "20/21",
                "num_reviews": 21
            }
        ]
    },
    {
        "Title": "web programming unleashed with cdrom",
        "description": "ActiveX controls, full-featured components, are the building blocks for creating active content on Web pages. This book covers ActiveX controls, ActiveX documents, Internet Server API, high and low level interfaces for downloading data from the Internet, and more. The CD includes various tools, demos and code examples.",
        "authors": "['Weiying Chen']",
        "infoLink": "http://books.google.nl/books?id=IOF6QgAACAAJ&dq=Web+Programming+Unleashed+with+CDROM&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "I found this book to be very very informative and a great learning tool! the major exception to this is Chapter 8 which is absolutely PITIFUL! this book is written by several authors, each with their own style. The author of Chapter 8 spends more time telling you what he is not going to teach you than actually teaching anything! Chapter 8 is &quot;Java Programming,&quot; do not buy this book for that. This book is truly great for any other Web-related programming/design topic, though. I still believe this book is a definite must-buy, just do not count on a very thorough understanding of Java without an additional resource.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            },
            {
                "review/text": "This book really doesn't give you imformation about any kind of web programming. It barely skims the surface of all the languages or scripting languages the book says it covers. A real waste of time.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "voicexml 20 developers guide building professional voiceenabled applications with jsp asp coldfusion",
        "description": "Engineer your way to excellence! This professional resource explains in full detail how to build VoiceXML-based applications using real-world programs you can adapt for your own projects. The book includes three full-scale, enterprise-level applications complete with all source code.",
        "authors": "['Dream Tech Software India Inc.']",
        "infoLink": "https://play.google.com/store/books/details?id=2N038ouxV-YC&source=gbs_api",
        "review": [
            {
                "review/text": "While this is the only book I could find with direct reference to VoiceXML, ASP and SALT, it was a dissapointment. The title says VoiceXML 2.0, but the major examples are all given in 1.0 syntax. There are many errors and the formatting is poor. Finally, there is no discussion about mixed-initiative applications or natural language processing.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "This is a no crap book. I didnt need a tome that would tell me what i want. I know what i need to do i just needed a book that would help in the How To part. Some of the application discussed in this book are of commercial quality in their design and funtionality. the stuff on the voice command performace shows the author's experiance on the matter. I could have done with some more stuff on IP telephony but the application discussed here elaborates a design which is common more or less in a lot of IP telephony apps. Nothing really usefull though but you can realy take the concept and the code further as you please and gives you something to think about. The very presence of the IP telephony introductory chapter in the books kind of completes the book and the discussion. I wouldnt mind though if this book had a few more pages and completed many application that i though were on the verge on being turn key solutions.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "professional php5 programmer to programmer",
        "description": "What is this book about? With the release of PHP 5 and the Zend Engine 2, PHP finally graduates from it earliest days as a lightweight scripting syntax to an powerful object oriented programming language that can hold its own against the Java and .NET architectures that currently dominate corporate software development. This book has a pragmatic focus on how to use PHP in the larger scheme of enterprise-class software development. What does this book cover? Unlike Java or .NET, there is little discussion of the application of design patterns, component architectures, and best-practices to the development of applications using PHP. Software written in the absence of this sort of higher-order architecture will never be able to match the robust frameworks that Java and .NET ship with out of the box. This book addresses this issue by covering the following material: Part 1 discusses the OO concepts that were initially explored in Beginning PHP 5 and a demonstration of how to implement them in PHP 5. This section also covers UML modeling and provides a brief introduction to project management techniques that are covered in more depth in Part 4. Parts 2 and 3 present objects and object hierarchies that, when completed, comprise a robust toolkit that developers will be able to reuse on future projects. These chapters are designed to arm the professional PHP developer with the sort of constructs that are available out of the box with platforms such as Java and .NET - from simple utility classes like Collection and Iterator, to more complex constructs like Model/View/Controller architectures and state machines. Part 4 shows how to use the toolkit from Parts 2 and 3 to create real-world applications. We look at the development of a robust contact management system that will leverage the componentry and concepts already discussed and introduce project management and software architecture concepts that enable developers to accurately identify business requirements, design scalable, extensible platforms, and handle change management effectively. It covers the waterfall and spiral project management paradigms and include a discussion on eXtreme Programming and other approaches to software development. The Appendices include an extended discussion on the effective use of CVS, introduce the Zend Studio IDE and related tools, and discuss performance tuning and scalability.",
        "authors": "['Ed Lecky-Thompson', 'Heow Eide-Goodman', 'Steven D. Nowicki', 'Alec Cove']",
        "infoLink": "http://books.google.nl/books?id=DQRBMWN_VJ0C&dq=Professional+PHP5+(Programmer+to+Programmer)&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "OK, first off, I'll be totally honest - I am the lead author of this book. So, of course, I'm going to give it five stars.But, I really do have to rebut the review of the above reader.He's right - there's very little PHP 5 'specific' information on this book. This is a book for people with a solid grounding in PHP already. I can't stress that enough. If you don't know PHP inside and out, this book is not for you. If all you want to know is the differences between PHP 4 and 5, this book is not for you (to be honest, there's a web page on zend.com that tells you the differences in just a few pages).If, however, you want to see how you can take your PHP development to a far higher tier than your peers, then this is the book for you. No other book treats PHP like a professional development language. Every other title insists on propagating appalling development practices, practices which are in part responsible for the majority of PHP on the web today looking like it was penned by a 13-year old in his bedroom.Not this book. This is a book for professionals - either existing professionals seasoned in Java/JSP, C++ or some other 'traditional' programming language who is looking for how they can apply the 'best practice' techniques they've already learnt to PHP - or, for aspiring PHP professionals who have a solid grounding in and understanding of PHP 4 or 5 already.Put it like this - I run a web agency. I am interviewing PHP people right now. Their code is truly appalling, universally, but I'm going to hire one of them. The one condition of their employment? That they read this book cover to cover before they start with us.Hopefully this gives you a bit of an insight into what this book is about. If you're looking for a gentler introduction to PHP 5, take a look at Beginning PHP 5, also by Wrox (to which I also contributed). If you're ready to become a respected industry professional, take a look at this book.",
                "review/helpfulness": "35/40",
                "num_reviews": 40
            },
            {
                "review/text": "First, visit wrox dot com and download the sample code that is available for free on their site.If you think you want this book, you probably already have php5/Apache/mySQL installed on your development workstation.Unzip the sample code, browse it using your favorite IDE. Note the usage of PostgreSQL instead of MySQL. Take a shot at executing the very simple OO sample files in the first chapter. Notice the syntax errors, the use of depracated functions, and errors in filenaming.This book was rushed through development, much like most poorly developed applications. Very much a shame. I bought the book based off of previous Amazon reviews but failed to visit the user forum on the wrox site.You'll notice there that the topic of greatest interest for this book is that of disappointment in it's development. In print for most of this year and not a single errata to correct the carelessness of the authors' inattention to detail.0 stars for typos.0 stars for poor sample code.0 stars for the editors.1 star for providing great general reference in the non-code oriented chapters.1 star for giving me the chance to fix the errors in sample code and offering it up to wrox in exchange for refund of this purchase.Be warned. This is a great reference book, the code is bukaki.",
                "review/helpfulness": "30/33",
                "num_reviews": 33
            },
            {
                "review/text": "This is obviously a book written by a collective of PHP4 programmers who have taken code that they've written and are familiar with (and which is sometimes outdated), and attempted to put a Object Oriented face on it in order to make a little money from this book.Notice that if you're looking for a comprehensive PHP5 book, this is not it. The authors don't even mention the new MySQLi extension for PHP5 nor the SQLite database. It's obvious they come from and are still in the pre-PHP5 world. They also are slanted towards Smarty page templates and using Postgres for their examples. They give only a passing mention (one page, three sentences) to MySQL.If you do buy this book, be prepared to go to www.wrox.com and the forums to find corrections to the code examples made by readers. Be prepared to re-write many of their examples.All in all, this might be a generally useful book, but be advised that the grammatical errors, code mistakes, and parochial attitudes don't make it the best.",
                "review/helpfulness": "13/15",
                "num_reviews": 15
            },
            {
                "review/text": "For years I have relied on the reviews on Amazon to help me select the technical books I would purchase, this is only the 3rd time I've been moved to actually write a review and the first 5-star rating I've given. I bought this book because it seemed to have a lot more depth on oop in php5 than other titles available. What I got was that, plus a whole lot more.If you are a garage php programmer, a hobbyist or a novice... if you don't make your living programming (or aspire to) - then this book is not for you.On the other hand, if you are a professional, you will find that this book is written by professionals with you in mind. All of the excellent PHP5 related instruction and reference is discussed in the context of serious development methodologies and practices. It gives you insight as to how a serious development team can (and does) approach large-scale development projects in PHP. Any by the way, it ends forever any doubts you may have that PHP could or should be used for such projects.Nice job guys! I only regret that I have but 5 stars to give.",
                "review/helpfulness": "11/11",
                "num_reviews": 11
            },
            {
                "review/text": "I agree that this book must have been rushed through development considering all the typographical errors, but I also agree that most of them are obvious and easy to overlook. I also agree that all the examples are written for PostgreSQL. I use both PostgreSQL and MySQL, so I don't have a problem with converting the code to use the new PHP mysqli functions. Other than quoting field names, there aren't many differences between PostgreSQL syntax and MySQL syntax. What this book does is start from chapter 1 showing you how to use Object Oriented Programming with PHP, and it does an excellent job of carefully covering each step so that you have a solid foundation to move to the next chapter. I love this book! Even with a mistake in the code on the errata page, it still rocks. Wrox books are the best!",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "I like the topics covered in this book. However, there are a number of grammatical errors throughout and the codes in the book are full of errors. If you're up for the challenge of surfing the books forum page at [...] to find code fixes, then this book is for you. But, if your not the adventurous type and like codes to work out of the box then this book isn't for you.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "Ok, before you buy this book check the publisher's forums (Wrox). It's a bad sign when you see a 3 page thread concerning errors (both with code and grammar).Of course I didn't follow my own advice. So I'm stuck. ;(Don't make the same mistake.",
                "review/helpfulness": "4/6",
                "num_reviews": 6
            },
            {
                "review/text": "This book is just what the PHP community needs. I come from a strong C++ background, and I have struggled with the huge amounts of poorly written PHP code out there. The PHP community needs to step up and become professional, and this book is a must read for anyone that wans to create solid software. This book touches on the most important aspects of high level software design using PHP. It also provides some usefule code and examples to help illustrate the benefits of proper Object Oriented design.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "I gave it 3 stars for the inspiration that the discussion of a great breadth of PHP/OOP topics provides. There's everything from design techniques to coding practices to project management. Unfortunately, the treatment of most topics is somewhat cursory and many of the code examples are either not thought out carefully or don't work. Thus the code, although it takes up a substantial part of the book, has to be seen as illustration material only. Some of the concepts I found confusing. For example, I am not quite able to understand the purpose of a collection class (chapter 5), given PHP's dynamical typing and associative arrays. Furthermore, the MVC model (chapter 13) is introduced as having a fourth \"infrastructure\" component. I am not sure what architecture model this would constitute, but it is probably not an MVC model. There are many such quirks in ths book. Programmers who are interested in advanced OOP concepts will find this book to be a good overview of methodical -as opposed to ad hoc- software construction with PHP. In order to actually learn and apply these techniques, a more thorough introduction to object-oriented theory and design is probably required.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "I have been a PHP programmer for several years now, and this book just took things to a new level for me. It inspired me to build more scalable and secure applications and to become a better programmer. Though this book is about Object Oriented PHP, it also covers things like Project Management, templating, and specific Design Patterns.This book is chock full of great code examples - real world examples. The authors have a great writing style that makes this book an easy read without getting bored or lost.If you are looking to become a professional PHP programmer, this book is a must read. It allows you to get a better grasp of OOP and its patterns and approaches.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            }
        ]
    },
    {
        "Title": "computational geometry in c",
        "description": "This is the revised and expanded 1998 edition of a popular introduction to the design and implementation of geometry algorithms arising in areas such as computer graphics, robotics, and engineering design. The basic techniques used in computational geometry are all covered: polygon triangulations, convex hulls, Voronoi diagrams, arrangements, geometric searching, and motion planning. The self-contained treatment presumes only an elementary knowledge of mathematics, but reaches topics on the frontier of current research, making it a useful reference for practitioners at all levels. The second edition contains material on several new topics, such as randomized algorithms for polygon triangulation, planar point location, 3D convex hull construction, intersection algorithms for ray-segment and ray-triangle, and point-in-polyhedron. The code in this edition is significantly improved from the first edition (more efficient and more robust), and four new routines are included. Java versions for this new edition are also available. All code is accessible from the book's Web site (http://cs.smith.edu/~orourke/) or by anonymous ftp.",
        "authors": "[\"Joseph O'Rourke\", \"Olin Professor of Computer Science Joseph O'Rourke\", \"Associate Professor of Computer Science Joseph O'Rourke\"]",
        "infoLink": "http://books.google.com/books?id=gsv7HALW2jYC&dq=Computational+Geometry+in+C&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This book provides a reasonable introduction to the field of computational geometry, although the notation is sometimes sloppy and the author frequently makes inconsistent assumptions about the reader. For example, on the first page he refers to a circle as a &quot;one-dimensonial set of points,&quot; which although valid from a toplogical perspective is a little confusing in an introductory text. As another example, the first exercise refers to &quot;every point in dP,&quot; presumably meaning just the corner points (otherwise the problem would be unsolvable). The book also sets up a lot of irrelevant mathematical definitions that generally obfuscate the presentation rather than clarifying it. Although not prohibitive for the ambitious reader, these needless hindrances are at best a little annoying.Secondly, I must criticize the text's scope, in light of the important role computational geometry has played in modern computer graphics. There is no discussion of clipping, culling, occlusion (e.g. BSP, octree, OBB), or even non-polygon primitives -- important topics arguably more useful to the target audience than e.g. convex hulls (to which over 1/4 of the book's pages are devoted).Regardless, this book (combined with a professor and a course) probably would serve quite well as an undergraduate text. Readers interested in a cookbook of applied graphics algorithms, however, should look elsewhere.",
                "review/helpfulness": "40/54",
                "num_reviews": 54
            },
            {
                "review/text": "O'Rourke's approach reflects the essence of both &quot;Computational Geometry&quot; and the &quot;C language&quot; --- concise yet profound. The book covers the core subjects of Computational Geometry: polygon partitioning, convex hulls, Voronoi diagrams / Delaunay triangulation, &quot;arrangements&quot; of lines, geometric searching, and motion planning.The book assumes some familiarity with the C language, but is very readable even for non-C programmers. This is an excellent text for use as an introduction to Computational Geometry, a primer for Preparata &amp; Shamos, while at the same time it's an excellent addendum to that more seminal text. By weaving working code into his presentation, O'Rourke gives traction to the powerful engine of Preparata &amp; Shamos.",
                "review/helpfulness": "21/24",
                "num_reviews": 24
            },
            {
                "review/text": "Anyone who is involved in areas such as computer graphics, computational radiology, robot vision, or visualization software should have a copy of this book. The author has done a fine job of introducing the most important algorithms in computational geometry, choosing the C language for their implementation. The choice of C might be somewhat dated now, since C++ is now beginning to dominate computational geometry, but readers who are actually programming these algorithms using C++ can easily extend the ones in the book to C++. Not all of the algorithms in the book are implemented into C, unfortunately, but the clarity of presentation is done well enough to make this implementation a fairly straightforward task. My interest in the book came from a need to design and implement algorithms for polyhedra in VRML and toric varieties in algebraic geometry. This book, along with others, was a great help in that regard. The running time of these algorithms was not really an issue with me, so the detail the author spends on discussing the complexity of the algorithms was not a concern. Readers who need to pay attention to running-time issues will appreciate his discussion of them for the algorithms that are presented.The ability to visualize objects in an abstract subject like algebraic geometry boils down to, in the case of toric varieties, to a consideration of how to manipulate polytopes geometrically. A major portion of the book, if not all of it, is devoted to the computational geometry of polyhedra. Because it is an introductory book, some more advanced topics, such as Bayesian methods to find similarities between polyhedra, and neural network approaches to classifying polyhedral objects are not treated. Readers who need to do such things will be well-prepared for them after a study of this book. In addition, there are good exercises assigned at the end of each chapter, so the book could be used in the classroom. Some readers will however choose to use it as a reference source, and it would be a good one, for the author gives references to topics that he only touched upon in the book.Some particular areas that were treated especially well were: 1. The discussion on data structures for surfaces of polyhedra. Although not very general, since he choose to deal with only triangulated polytopes, readers who need to be more general will have a good start in this discussion. 2. The discussion on volume overflow and how to deal with it using robust computation. 3. The discussion, albeit short, of the randomized incremental algorithm. 4. The treatment on the minimum spanning tree and Kruskal's algorithm. Communication network performance optimization is now a major application of this algorithm and others in graph theory, including the author's later discussion of Dijkstra's algorithm.",
                "review/helpfulness": "13/13",
                "num_reviews": 13
            },
            {
                "review/text": "This book was pleasantly surprising: I had expected to see code presented with minimal motivation or discussion of the underlying ideas -- something of a &quot;Computational Geometry for Dummies&quot; sort of book. That's not the case at all. This is a bona fide textbook on the subject, suitable for an undergraduate course.It covers all of the the &quot;classical&quot; topics: convex hulls, line segment intersection, polygon triangulation, Voronoi diagrams, motion planning.The mode of presentation -- supporting a discussion of the theories with implementable code -- is actually a bit refreshing. For comparison: Other books, when discussing the line segment intersection problem (ie: Given a set of line segments, find all of their intersection points) simply assume that computing the intersection of a pair of segments can be done in constant time. This is not an especially difficult problem, but the discussion seems more complete with a brief description of how this might be done. The same can be said about other primitive tests and operations in other algorithms.Overall, this book can stand alone as an excellent introduction to computational geometry, but a serious student in the subject will want more: perhaps Preparata and Shamos or de Berg et. al.",
                "review/helpfulness": "10/11",
                "num_reviews": 11
            },
            {
                "review/text": "I bought this book to learn about convex hulls, voronoi diagrams and delaunay triangluations, and line arrangements. So far I have made it through the chapter on 2D convex hulls, and I must say that it is an excellently written book for learning about the covered topics in computational geometry. The text is clear easy to understand; algorithms are sufficiently detailed and illustrated to allow full implementation without needing other resources. Corner cases are meticulously covered. I also like the text because it is straight to the point, i.e., it does not spoon-feed the reader. So, although relatively short book, it contains a lot of densely packed, but still enjoyably readable, information. Illustrations are simple but excellent: they are carefully designed and very helpful for understanding the described algorithms.I give the book four stars for two reasons.First, the coverage of floating-poing precision issues is almost non-existant: most of the algorithms are integer-only. A survey chapter over techniques for handling FP precision issues would be *VERY* welcome. (After all, geometric algorithms are most often applied to floating-point data in the real world.) Judging by the quality of existing bibliography, I think the author would make an outstanding job on this topic. (Hint for the 3rd edition :-))Second, I have strong objections against the coding style used in this book: the presented code is an excellent demonstration of how to obfuscate C programs by using typedefs and hungarian notation (inconsistently!) applied in postfix. (NOTE: I have 10+ years of experience in C and C++ coding, so I'm not just a \"little bit confused\").",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "ai4u mind11 programmers manual",
        "description": "AI4U: Mind-1.1 Programer's Manual has the following positive and negative points.+ It describes the rapidly evolving AI Minds on the Web. - It quickly becomes obsolete as the AI hyper-evolves. + On-demand publishing (ODP) makes for quick updates. - The Mentifex project is considered oddball on the 'Net. + You've got the first book about the first real AI Mind. - There are other, better, more authoritative AI textbooks. + AI4U makes a good supplement for actually coding AI. - Artificial intelligence is too hard to understand. + AI4U describes the AI while it is still easy to learn. - \"I would rather build robots than study AI programming.\" + If you want to build a smart robot, then AI4U is for you. - \"I'm only a high school student/teacher; what's the use?\" + This book will challenge even the most gifted student. - \"I am not a programmer and so I can't code AI.\" + AI4U teaches you how to operate an AI, not just code it. - \"I just want to do Web design, not artificial intelligence.\" + AI4U provides an AI that you may install on your website. - \"I am more interested in neuroscience and/or psychology.\" + AI4U teaches a theory of how the brain works psychologically.",
        "authors": "['Arthur T. Murray']",
        "infoLink": "http://books.google.com/books?id=YuN7PwAACAAJ&dq=AI4U:+Mind-1.1+Programmer%27s+Manual&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "There is no polite way to say this. The author is a crackpot. Reading the materials he provides on his website, an astute reader will notice several things. Firstly, this person doesn't know how to design software at all. He also presumes that his reader knows even less than he does. The \"AI\" he proposes is nothing more than a basic for(;;) loop. (One of the primitive constructs provided by C, C++, Java and their dirivitives...). He is aware of some of the limititations of his design but is unaware of their obvious (to any intermediate-level programmer) work-arounds. Secondly, while he is happy to put lavish names, such as \"Sensorium\", on empty or nearly empty functions, he seems to be completely oblivious to the real issues a succesful AI mind must address.He throws about refferances to concepts in the AI and futurist community such as the technological singularity but fails to demonstrate any understanding of what they mean. He claims that his design solves the AI problem when, infact, it hardly does anything at all.He claims that his system is suitable for use in robotics, yet he has done no orrigional experamentation.He continues to troll the usenet (sending between 5-7 messages to every AI and transhumanism related newsgroup per month) pushing his book and his lame ideas.. (If his ideas had even a tenth the merit he claims he would be world-famous...)I am an AI enthuseast myself and hope to, oneday, publish my own work on the subject. (you can find some of my writings on my website). I do not have the audacity to claim that my work is yet worth anything because I have not yet made much progress. In general, you should stay away from all books on AI unless they are based on actual work that has been done in the field. Work, in this case, being either hard research on biological systems or software development efforts that have shown some type of results.",
                "review/helpfulness": "33/38",
                "num_reviews": 38
            },
            {
                "review/text": "From any decent developer, you would expect something, which would at least compare to Winograd's SHRDLU. For some reason, the book however is failing to show any results of the \"software-architecture\" being explained in length!A scientist's moral dictates, that you withdraw your theories, if you have been proven wrong. Arthur T. Murray however doesn't show any inclination to do so. Instead he is still continuously advertising his long ago falsified book in forums and he's claiming to have developed a powerful approach to AI.I think, I can safely say, that the author is a phoney and he's only trying to sell his book. So take my advice and don't by it (as I did)!",
                "review/helpfulness": "20/23",
                "num_reviews": 23
            },
            {
                "review/text": "Murray believes that with the spread of activationthrough a network of the correct configuration andsufficient size you have intelligence and thought.Not everyone would start from that premise butprobably most connectionist do. While AI4U issometimes advertised as a \"textbook\" it is notthat. An AI textbook should discuss at least thecore AI topics:searchpattern recognitionknowledge representationlearninglogicrule-based systemsneural networksetc.While AI4U touches on some of these topics itis not an adequate textbook. Rather it is adefence of one man's approach to building anartificial intelligence.The chapters in this book are too brief andthe discussions too superficial. There also needto be algorithms provided for each routine in thecode of Appendix A. These could be presented inpseudocode or as flowcharts for instance.The biggest problem is the lack of references.It is just possible that one could write a shortnote without finding it necessary to reference thework of others but it is impossible to write a booklength scholarly work without citing other work inthe field. This is a fatal flaw. Murray shouldbegin by referencing:The Structure of Long-term Memory, W. Klimesh,Lawrence Erlbaum, 1994Netl, S. E. Fahlman, MIT Press, 1979Adaptive Information Retrieval, R. K. Belew, U. ofMichigan, PhD thesis, 1986The authors of these works have accomplished someof the things Murray is trying to do with Mentifex.A positive side to Murray's work is that he doesprovide downloadable code. When you run this code youfind that Mentifex is very slow even with a very smallsemantic network. If one were to build up the millionsof nodes needed to approach human level intelligencethe code would grind to a halt. Murray seems to thinkrunning Mentifex on parallel processors will solvethis problem. I calculate that it will not. Ibelieve human level preformance requires that oneapply multiple approaches to controling complexity:category formation by clustering/vector quantizationhierarchical knowledge organization/processingparallel processingavoiding search whenever possiblesimultaneous use of multiple specialized agentssequential running of multiple generations of agentsplus any other means you can bring to bear.(see Asa H, R. Jones, Transactions of the KansasAcademy of Science, vol 109, No. 3/4, pg 159, 2006)",
                "review/helpfulness": "9/10",
                "num_reviews": 10
            }
        ]
    },
    {
        "Title": "ibmr webspherer application server programming",
        "description": "Develop and deploy powerful Web-based applications on multiple platforms--including UNIX, NT, and AIX. Packed with essential information as well as advanced techniques for developers and system integrators, this book will help you maximize every aspect of WebSphere's functionality, and fully leverage the power of this key e-infrastructure software. Covering core Web technologies including EJB, J2EE, and servlets and including original source code for hundreds of working programs, IBM WebSphere Application Server Programming belongs in the hands of every serious WebSphere developer and system integrator.",
        "authors": "['Bassem W. Jamaleddine']",
        "infoLink": "https://play.google.com/store/books/details?id=7NB3tkgSMpwC&source=gbs_api",
        "review": [
            {
                "review/text": "I particularly like the flow from one chapter to the next and the reuse ofthe code. The author carefully used a development tree to prove WAS run-timeeffect in classloading. The reader will realize how the tree hierarchy andits organization can impact the visibility of the classes. This is the onlybook I've found that explains WAS run time and the classes loading andvisibility. Chapter 15 is a corner stone to understanding WAS classloading.I use the IBM Infocenter as a reference, but the real meaning of hotdeployment is realized practically in this book; a set of cleverly writtenscripts are utilized throughout Part III to hot deploy a web applicationquickly.I liked the development from servlet to EJB, taking code the readers shouldbe familiar with and putting an EJB wrapper around it was a fine idea.Using Apache SOAP and writing a serializer and a deserializer to access theseEJBs was also a great idea.Our company still uses CGI, and I found this book an excellent resource asit is quite direct in showing the utility of using both CGI and Servlets inthe same context of a Web site.Strange enough, I am not a Perl programmer (in fact, I quite often avoidir). Now that I have read this book, I bought the Perl Cookbook tosupplement my library.The system processes and network ports and socketsused are clearlydemystified. The book is straightforward and clear. There is no singlereference to WSAD and Visual Age, except in Chapter 1 where the author madeit clear that neither WSAD or a Visual Age product will be used this book.This is really a book for the community as it opens AS to the public withoutusing any of IBM proprietary software or tool-sets to the understanding andprogramming of J2EE web application in WAS. Interesting nomenclature. A wellorganized book. Couple of typos. But overall I will give it 4 and 1/2 stars.",
                "review/helpfulness": "5/7",
                "num_reviews": 7
            },
            {
                "review/text": "Learn WebSphere from the inside out. This book dispenses with the usual abstractions and details step by step every example and technique. The book starts with installation, moves onto administration and builds on this knowledge to build an application database and finally a complete application. This book contains advanced chapters on performance and monitoring.What sets this book apart is the depth, it moves below the usual abstractions and reaches the inner WebSphere core.Based on purely freely downloadable tools, this book is great for students on a budget and contains sufficient grunt for the seasoned professional code cutter or sysadmin.I guarantee you will never read a WebSphere book quite like this one, it has introduced me to a completely different way of viewing WebSphere and J2EE.",
                "review/helpfulness": "5/5",
                "num_reviews": 5
            },
            {
                "review/text": "This is a book about WAS -- WebSphere Application Server -- whose contents stick concisely to its title.As a reader, I was surprised that the author really took the opposite tack using standard UNIX commandsthan every other WebSphere book to discuss the administration and programming in WebSphere ApplicationServer while totally avoiding WSAD or Visual Age.Any reader can just start with a Linux machine, a text editor, and WebSphere Application Server solelyto learn the inside and out of the latter.The book teaches you a step by step installation, followed by testing the installation and administration;then progressively programming a web application that flow from one chapter to another; then stresstesting the web application; and finally monitoring, tuning, and risk managing WAS and the web applications.The book teaches you how to deliver WebSphere applications with maximum performance and availability.This book also offers free download for a toolkit and the WebSphere monitoring application foranyone who would like to supplement his or her computer system executable with extra tools to benchmarkWeb applications, to monitor processes and threads, to add a WAS risk management application, etc.The writing is solid and the technical approach using the standard UNIX shell scripts and the makeutility untied this book from a specific version of WAS.The learning vehicle focuses on concrete commands that show you what is happening behind the sceneof web applications programming.Being a book whose contents stick to its title, this is a 4+ stars book (and a 5+ stars once the electronictypos are corrected).This is a fine book in distributed systems to be added to the computer science library.",
                "review/helpfulness": "4/4",
                "num_reviews": 4
            },
            {
                "review/text": "From the many books that I have read, this is the first and only one thataddresses WebSphere Risk Management. The author did an amazing job inintroducing his monitoring applications: WASLED / WASMON (a totallyfree application for non-commercial use).The monitoring is totally independent from any WebSphereAPI's, which set this monitoring application far above applications thatimpact the performance of WebSphere.Though too short, the performance and tuning chapter is really amazing. ABrief section about EJB-container performance is thoughtfully andcomprehensively written.A competent yet non-pedantic use of real computerscience nomenclature sets this book apart from run-of-the-mill computertrade books. It is balanced writing that is careful (for the most part) toplease both the reader of highly technical material and the new comer toWebSphere as well.The programming flow from chapter-to-chapter ensures a pre-matureoptimization, where the notation of throwable exceptions is kept to a minimum.Yet. this is the first book to show full-blown exception handlers that can beput in the center of any enterprise web application: a total working code --gratis!I have no reason to give this book less than a well deserved 5 stars. Thisis a fine book and a great value...",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            },
            {
                "review/text": "Excellent book for all Linux and UNIX users. This book offers plenty of insight into the administration and programming of WebSphere that helped me to understand many interesting points such as J2EE classloading under WebSphere runtime, HTTP session persistence (persisted to database), the web container and JAAS-securing servlets, beans to be turned into web services, etc.This book is highly technical, and it offers also insight into the administration way of thing. I recommend it for real enterprise application development.Absolutely to be read.",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            },
            {
                "review/text": "I brought this book seeing the reviews of many thank full friends and i am impressed.I have read the first 4 chapters untill now, and I liked the new topics and ideas the author has introduced. They are very usefull in every stage of developing J2EE applications. I am sure any one who read this book wil have a thorough grip of websphere functionality.Also this book is for versions 3.5 and 4 but the author has mentioned the version 5 specific changes also.I am giving 4 stars for its detail explanation of websphere install,configuration, programming and fine tuning.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "applied probability and stochastic processes",
        "description": "In this book, Feldman and Valdez-Flores present applied probability and stochastic processes in an elementary but mathematically precise manner, with numerous examples and exercises to illustrate the range of engineering and science applications for the concepts. The book is designed to give the reader an intuitive understanding of probabilistic reasoning, in addition to an understanding of mathematical concepts and principles. Unique features of the book include a self-contained chapter on simulation (Chapter 3) and early introduction of Markov chains.",
        "authors": "['Richard Martin Feldman', 'Ciriaco Valdez']",
        "infoLink": "http://books.google.com/books?id=JRbvAAAAMAAJ&dq=Applied+Probability+and+Stochastic+Processes&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "I randomly ran across this book in my math library trying to find an extra book to help with the difficult Stochastics Process class I was taking. Little did I know I would find a book I value as much as Douglas Kelly's Introduction to Probability. This book has applied problems and examples! It is not the dry, endless pages of confusing equations we have come to expect from Stochastics Processes books. There is something better out there! This book saved me as an undergraduate, and am now looking forward to it living up to my God like expecations as a post grad. If you are a professor, please use this book for you students. It ties together and lets you appreciate many fields such as linear analysis and even graph theory from computer science. This book will not disappoint.",
                "review/helpfulness": "11/11",
                "num_reviews": 11
            },
            {
                "review/text": "Extremely clear, and easy to understand. It is the best introductiory book on stochastic processes for non-mathematics major. After you read this book ( one month is enough, how amazing it is!), it becomes easier to read &quot;the first course in stochastic processes&quot;. The book focuses on the concept and intuition, instead of proof, and I find it is extremely useful for me -- CS major.Strong recommend this great book",
                "review/helpfulness": "7/7",
                "num_reviews": 7
            },
            {
                "review/text": "A lot of examples, easy to read. A lot of stochastic and queueing books are usually full of notations and theorems, thus hard to understand. However, the author of this book presented the materials in a way that we can actually understand the stocahstic processes. If you want to learn queueing and do not have much background, this is the book!!!!",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "programming jakarta struts 2nd edition",
        "description": "Discusses how and why to configure and develop Web applications with Struts and other Jakarta technologies using the model-view controller design pattern in Java.",
        "authors": "['Chuck Cavaness']",
        "infoLink": "http://books.google.com/books?id=E874l0jaUGQC&dq=Programming+Jakarta+Struts,+2nd+Edition&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This book is a must have! I've been programming with Struts for about 6 months and I didn't want a beginners guide. This book hits the perfect level with me and covers the stuff that I wanted to know about. It's definitely not a beginners guide, although I think even beginning Struts developers should read it to save themselves time later.Here's why I'm giving it five stars:Chapter 1 - Covers MVC and Model 2 Background and TriviaChapter 2 - Covers Request/Response and Forward/Redirect InfoChapter 3 - Good overview of the framework with the Bank example (All banking code is provided, including Ant scripts)Chapter 4 - A complete chapter on configuring the web.xml and struts-config.xml (Some parameter are missing because of changes after book release)Chapter 5 - A great chapter on explaining the controller of StrutsChapter 6 - The reason to buy this book! Everything you ever wanted to know about how to build the model for StrutsChapter 7 - Dynamic Forms Coverage (Good Coverage)Chapter 8 - Tags (This chapter could have been better!)Chapter 9 - The explanation of why and how to extend Struts if neccessary for any real Struts applications.Chapter 10 - Great coverage of the declarative and programmatic exception handlingChapter 11 - Coverage of the validator framework. Also covers how to create your own rules and to use it outside of StrutsChapter 12 - Good I18N CoverageChapter 13 - Excellent chapter on EJBs and Struts (A must read!!!)Chapter 14 - Tiles, but I've not read this chapter close enough to comment.Chapter 15 - The best information available on Logging in a web application (A must read by all!)Chapter 16 - Solid coverage of using Ant to package Struts. (Ant scripts are included)Chapter 17 - Decent chapter on PerformanceOverall, each chapter covers exactly what more advanced Struts users want and need.You can't go wrong buying this book!",
                "review/helpfulness": "34/41",
                "num_reviews": 41
            },
            {
                "review/text": "The target for the book is any experienced Java developer who is interested in Struts but has little or no experience with Struts. The book starts with an explanation of why Struts is a &quot;good thing&quot; and shows how Struts fits into a web architecture. The author then gives an explanation of each of the pieces of the Struts architecture and demonstrates a simple application. Although the explanations were clear, I felt that the author was making the architecture overly complicated by explaining things out of order. A diagram showing the interrelationships of the different Struts classes and config files would have been helpful. The author covers all the expected topics such as internationalization, exception handling, logging, and the Struts tag libraries. The chapter on the Struts tag libraries could have used more examples to make the explanations clearer. The book concentrates on Struts 1.1 and the author does a nice job of explaining the changes from the 1.0 version and the features available in the new version. The chapter on the new Validator framework is clear and the examples are on target. The chapter on Tiles is short but the author does a great job of explaining how it fits into the Struts architecture. The chapter on performance seemed completely unnecessary since there was nothing in it specific to Struts. Overall this book is a good addition to the Struts library. The book has some shortcomings but it provides a good deal of value.",
                "review/helpfulness": "21/26",
                "num_reviews": 26
            },
            {
                "review/text": "I've relied on O'Reilly books to provide the gist for any number of topics but this one disappoints on a number of levels. Too much filler material (if you don't know about EJBs and WARs then you shouldn't be reading this book) and an imbalance of detail. I need to know how to enable debugging in struts-config.xml or how to specify the message properties files in web.xml, not individual attributes to custom tags; I can find those in the javadocs.Granted it's a relatively new technology but this treatise didn't provide much more than what I could find on-line. There wasn't even decent coverage of the specifics of minLength and other validator features. Trash the fluff and stick to the details which implementors require and you might have a decent book.Now I'll just have to buy the Husted tome. It's not like I'm made of money, you know? I just can't recommend this book to someone trying to develop a production application in \"web time\".",
                "review/helpfulness": "23/26",
                "num_reviews": 26
            },
            {
                "review/text": "I've wanted to write a review for this book ever since I started reading the draft chapters on theserverside.com. I was one of the many who participated in submitting feedback from the very beginning and feel like I've learned so much from the material, but understand how someone might not get it immediately.This book was written specifically to teach Struts developers how to fish; it wasn't designed to fish for us. This is something the Author mentioned on the list many times. You won't find a million different ways to use a specific tag for example. Instead, I think the coverage is more advanced and attempts to strive higher than just Struts.So, here's my review for this book. I hope it helps you decide whether this book is for you or not.First the bad - This book is light on the tags section. If you are looking for every which way to use the iterate tag for example, you won't find it here. Also, the modules coverage could have been better. Of course, I think that's due to the flux that modules was in at the time of release. I don't personally hold this against the Author. The other books (especially the ones that came out before it) have the same issue.The other topic I would have liked to see covered in the book is Security. It's actually not covered in any of the books very well. Based on the earlier table of contents that the Author published, it was included. However it was posted on the mailing list that the chapter on security was being cut due to size and time. Maybe the 2nd edition will add this (hint, hint).Now the Good - This book covers so much about how to hook Struts up to a Model architecture; especially Chapter 13 (the one on EJB). I really like this chapter and have learned so much from it. The examples are clear, concise and helpful.The coverage of exception handling is superb! As is the coverage of logging (using log4j), tiles and the validator framework. The packaging chapter was very beneficial as was the chapter on I18N. However, what I liked about this book the most and what I think is the most valuable is the following:The Author clearly has built Struts applications for real companies and it's obvious to me (at least) that he's sincerely trying to communicate what's important for the big picture.So my advice to you if you are considering buying this book is, if you want to see how the tags can be used in every situation, buy another book. Actually you'll probably have to just read the user guide because I don't think the other books cover this any more. On the other hand, if you want to learn the 1.1 features in depth and learn big picture ideas and concepts, then I wholeheartedly recommend this book. It's possible that you won't appreciate all the material in the beginning, but after you work with Struts for 6 months, you most certainly will.",
                "review/helpfulness": "18/20",
                "num_reviews": 20
            },
            {
                "review/text": "Programming Jakarta Struts is a great book. I wanted to give it 4 1/2 stars but Amazon doesn't allow that. I bought this book the first day it came out and read it cover to cover. This was one of the first books out that covered Struts 1.1 in any detail. Chuck Cavaness, the author had published most of the book on TheServerSide.com where readers could review the beta copy of the book and so I knew this was going to be a great book.I just finished teaching a 6-week Struts class and used this book for that class. The book starts with intro to Web development, servlets and JSP pages before jumping into the basics of the Struts framework. Chuck does a great job in breaking down the components of the Struts framework and explaining them in details. After the intro, the book builds into the guts of the Struts framework with detailed chapters exploring MVC, the Action classes, Model components and the display tier.The chapter on tag libraries is very well written. The author mentions JSTL, the JSP Standard Tag Library but only includes a 2-page summary of JSTL. I wish the section on JSTL had a little more meat to it. I think this probably had something to do with the timing of the publication of the book and the JSTL standard.I also liked the chapter on the validation framework. With the framework wasn't covered in any detail, there was still enough information to get you started with the validation framework. In the later chapters, the author discusses EJB integration in Struts and provides some good best practices for that integration.To summarize, this is a great book and has to be one of the best Struts tutorial books out there. I should know, as I own about five Struts book. I would highly recommend this book to anyone looking to learn more about Struts.",
                "review/helpfulness": "11/17",
                "num_reviews": 17
            },
            {
                "review/text": "I read the draft chapters of this book and found the coverage to be excellent and the author's style to be very good. The material that was posted to theserverside.com was so helpful and shows that the author is comfortable with his ability to write and teach the topic of Struts.Reason why this is must have:- Covers Struts 1.1- Covers advanced topics- The exception handling and logging chapters alone are worth the $$$- Covers how to use Struts with EJB- Is well written- I have found no errors so far- Published by O'Reilly (need I say more?)- Source code for the storefront and banking apps is availableI also purchased the book by Manning and like it, although I prefer the O'Reilly book a little more. The direction of each book is slightly different and actually complement each other very well.O'Reilly and the author should should for commended on allowing the chapters to be reviewed before the book is available. That takes guts and confidence. My hats off to both.Excellent book!",
                "review/helpfulness": "14/16",
                "num_reviews": 16
            },
            {
                "review/text": "Struts has quickly become the leading framework for developing Java-based web-applications. This book does a terrific job of discussing the various elements of the Struts framework, from the ground-up. Starting with an introduction to the MVC pattern, the author clearly defines the role of the basic elements of Struts and delves into how to model and extend these components to write real-world applications.For users already familiar with Struts, the book expands beyond the basics and discusses how to use some of the libraries surrounding Struts, such as the Validator framework, Tiles, Logging (Commons, log4j). There are great chapters on using Struts with EJBs, exception handling, internationalization, the various tag libraries that come packaged with Struts, and advanced Struts features (some of which are new to version 1.1).If you are new to Struts or are already using Struts, I have no doubt you will learn plenty from this book. (Like most O'Reilly books) It skips on providing information irrelevant to the technology, and focuses specifically on how to help you build and model clean, maintainable web-applications. Gone are the days of including JSP scriptlet code inside of your HTML (I know I'm tired of looking at it). I've used Struts to build the past two web-applications I've worked on and I have no doubt I'll use it for the next - this book will be right beside me.",
                "review/helpfulness": "13/15",
                "num_reviews": 15
            },
            {
                "review/text": "I'll start off by saying that I have limited experience with Java or JSP. I have done some programming in Java and JSP but I have not delved into any of the more advanced features or into some of the basic features. So I began reading this book with the hope of some clarifications to help me get by my ignorance. The author was very good at helping me understand all the other necessary concepts before delving deeply into struts.The first thing that I liked about this book was that it was easy to read and does not have too much technical jargon. When the author uses any technical words, he explains pretty clearly what the word or abbreviation means. This is invaluable to newbies like myself. I really like the first few chapters because they not only explain clearly what struts are but also gives you alternatives to struts and their advantages. The rest of the chapters go into pretty good detail in describing what struts can do and how to get them to do what you want.One thing that always makes me like a book are the &quot;pretty pictures&quot;. This book has plenty of useful diagrams and code examples that allow you to visualize the concepts. As usual with O'Reilly books, you have their website that contains more examples, errata and other important information to help you to become more Strut adept.Overall, I liked the book. It was not confusing or vague. The author explained clearly his purpose and successfully accomplished it in the book. I may not be a struts guru right now but I certainly have the tool to help me become one.",
                "review/helpfulness": "10/14",
                "num_reviews": 14
            },
            {
                "review/text": "For the last year or so I have been using Struts so I do not consider myself to be a starter. I read the book (almost cover to cover) and it is a good book. But it should be called 'starting with Struts'. Compared to other O'Reilly books (which i typically love) it does not have enought concepts and it does not have sufficient detail. What is left is a very, very good programming manual for a beginning Struts developer but a too limited resource for the more advanced strutsee. I am now going to read the Husted book, I hope to be more positive about that one.",
                "review/helpfulness": "9/12",
                "num_reviews": 12
            },
            {
                "review/text": "This book does an excellent job of laying out the Struts framework at a high level and then explaining each individual component of the framework in detail. It provides clear examples of good design patterns separating the business model from the view/controller of the application, and decent documentation of the use of each parameter in the configuration files.What it does not do is provide easy, step by step, &quot;this is what we just did and this is the result&quot;-style tutorials on building your first Struts application.I read most of the book without attempting to sit down and write any code. When I finished reading, I had a clear understanding of how the framework operated and a good idea about how I wanted to build my first Struts application. However, when I sat down to actually code the application using the book as a reference, I was completely lost.I must say that I am disappointed because the book does seem to market itself to all levels of Struts developers, but I think it's really only useful to somebody who has already gone through a few tutorials. I learned more about building my first Struts application by following tutorials in the MyEclipse IDE, and reading the code and configuration files from existing Struts applications.I give this book 1 star for beginners and 5 for experienced developers - so let's call it a 3.",
                "review/helpfulness": "12/12",
                "num_reviews": 12
            }
        ]
    },
    {
        "Title": "parallel and distributed programming using c",
        "description": "This text takes complicated and almost unapproachable parallel programming techniques and presents them in a simple, understandable manner. It covers the fundamentals of programming for distributed environments like Internets and Intranets as well as the topic of Web Based Agents.",
        "authors": "['Cameron Hughes', 'Tracey Hughes']",
        "infoLink": "http://books.google.nl/books?id=9L5RZ6-IpLEC&dq=Parallel+and+Distributed+Programming+Using+C&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This book covers the MPI (Message Passing Interface) library, the PVM (Parallel Virtual Machine) library, and the MICO (CORBA) library. If any these libraries were new to you, then this book is would be very beneficial to you.So many books have been written on PTHREADS, threading, multiprocessing, etc, and yet, this book seems to cover more grounds, teach more concepts, and show you more simple but useful examples that any other one's that I have seen. The books on PTHREADS cover threading, there are a number of books on multiprocessing, networking (Stevens book comes to mind), but as far as generic multiprocessing, and parallel processing is concerned, this book is the key. Hughes and Hughes have written another similar book, but that book mainly covered C++ and threading (hence the title of the book). This book covers other great C++ tools such as the PVM (parallel virtual machine), which to my limited knowledge has not been covered greatly in any other books.The first couple of chapters cover basic Operating System stuff. I don't know if it's because I have working for a number of years, or not, but the it actually made sense. We all have read the ever popular Modern Operating Systems book, but that book is somewhat dry. Maybe I think that say since I HAD to read the book for my class, but that feeling hasn't changed. This book covered the topics that you NEED to know, if you want to be able to write a program that takes advantage of some of the libraries mentioned above (MPI, PVM, MICO, and PTHREADS). It talks about the benefits, differences, and ideas behind parallel and distributed programming.The next two chapters are probably the best chapters I have read on the topics of Multiprocessing and Multithreading respectively. The chapters are titled \"Dividing C++ Programs into multiple tasks,\" and, \"Dividing C++ Programs into multiple Threads.\"I cannot say enough about how good these two chapters cover the topics. They start by the definition of both models, and they peel the onion as each chapter moves along. By the end of the chapter, you have seen examples, different design models for each method, and the pros and cons of each design model. Following these two chapters, a chapter is dedicated to synchronization and issues that go along with that in multithreaded/multiprocessing applications.PVM, the Parallel Virtual Machine, is covered in chapter 6. This chapter must be my favorite chapter in the entire book. The authors give the following description for PVM:\"The PVM represents a collection of networked computers to the developer as a single logical machine with parallel capabilities.\"The authors goes further and says:\"The PVM library is perhaps the easiest way to add parallel programming capabilities to the C++ language.\"In general, the PVM is broken down into seven categories:i) Process Management and Control: Routines used to manage and control PVM processii) Message Packing and Sending: Routines used to pack messages into a send buffer and send messages from one PVM process to anotheriii) Message Unpacking and Receiving: Routines used to receive messages and unpack the data from the active bufferiv) Task Signaling: Routines used to signal and notify PVM processes about the occurrence of an eventv) Message Buffer Management: Routines used to initialize, empty, dispose, and otherwise manage buffers between PVM processesvi) Information and Utility Functions: Routines used to return information about a PVM process and perform other important tasksvii) Group Operation: Routines used [in] joining, leaving, and otherwise managing processes in a group.The authors then go in to detail covering the two programming models used commonly with the PVM: SPMD (Single Program Multiple Data), and MPMD (Multiple Program Multiple Data):\"In the SPMD model, the tasks will execute the same set of instructions but on different pieces of data. In the MPMD model, each task executes different instructions on different data\"The topics covered in PVM also apply to the chapter that covered MPI, the Message Passing Interface covered in Chapter 10. The authors go a step further in this chapter and talk about how some of C++ features such as polymorphism, generic programming and templates, and operator overload can be used in conjunction with the MPI to make programming simpler and more efficient.The authors go into detail in the next few chapters about the Software Engineering aspects of the topics covered. Modeling aspects are covered first, and then applications and design. UML is used to show the readers how to represent concurrent and parallel designs. Flow charts, activity diagrams, class diagrams and state diagrams are used to represent the examples that were covered throughout the book.A closer look at C++ and Object Orientation covers some advanced topics in the book. Various C++ class types are used in examples to show the modeling aspect and then the designing aspect of concurrent and parallel programming.The last chapter of the book uses all the concepts covered in the book to implement a full-blown blackboard application. The BB is an approach to collaborative problem solving. The BB is used to record, coordinate, and communicate the efforts of two or more software-based problem solvers. The authors design and implement the BB using various architectural methodologies covered in the book: using the PVM, Threads, and CORBA. The examples certainly put everything that were covered in the book in perspective and enable the user to understand and grasp the topic at hand very simply.C. Hughes and T Hughes picked a very difficult topic to cover and they did one fantastic job at doing so. The examples are great. The topics are covered very thoroughly, and yet are very understandable. Any series C++ programmer, developer, or architect would benefit lots from this book.",
                "review/helpfulness": "18/26",
                "num_reviews": 26
            },
            {
                "review/text": "Even the bad reviews here are too kind. What can I say about this book? Let us start with Chapter 7, which is about exceptions and error handling -- as applied to parallel programming you'd think. But there is nothing about parallel programming and nothing good about exceptions in this chapter, which reads like a blog written by a C++ programming beginner who has just stumbled upon exceptions and thought, hey this is cool, nothing of the sort in Fortran, let me write about it.Section 9.2 talks about using template functions for parallel programming. Their examples are of the sort: (if rank is 0, let us call the multiplies() fn that is templated on int; if rank is 1, let us call the multiplies() fn that is templated on double). What were these people smoking?Section 9.3 overloads stream operators (&lt;&lt;,>>) to do MPI send/recv. This is bad design because the rank of the other process (for one) is an input to the MPI functions, so there is a stream class per other process - which is more messy than convenient. A better design would be to make a communicator class with send(), recv() fns taking the other rank as input. This would also support collective (gather, scatter) communication. Not to mention *unbuffered* MPI send/recv calls can be terribly slow, so there should be some buffering support.This brings to my basic gripe about this book: it is incredibly shallow. Of course it is garbage to an expert, but even to the dullest of beginners it can be of little use. Just about anything that you can find on parallel programming or C++ is better than this.",
                "review/helpfulness": "13/14",
                "num_reviews": 14
            },
            {
                "review/text": "I gave it 3 stars only because there are few books on the subject; it deserves only 2.The main problem I see with this book is that it tries to cover too much ground, even with subjects that it should not touch upon: there are whole chapters (7 and 9, for example) that are more about C++ than parallel or distributed programming, and one chapter (10) is about UML. Although it is interesting to see C++ and UML techniques applied to parallel and distributed programming, this leaves little space left for the coverage of MPI, for example. PVM and pthreads are given somewhat more attention, but still not nearly enough.Another problem is that the examples are mostly incomplete code fragments. There are few complete, running examples. I hoped to see bigger examples in the last chapters (they seem like case studies), but again they are made of too much \"talk\" and no code.The chapters are mostly independent of one another; it can be good if all you need is a quick first read on one of the subjects, but it gets annoying if you try to read it sequentially. Exercise for the reader: count how many times the PRAM model is cited AND explained.To say something good about it, the book has some nice general musings about the nature and fundamental problems of concurrent systems. But it is not a coherent whole and is not particularly good at explaining any of the myriad subjects it touches upon.Bottomline: It's neither an applied book about specific technologies, nor a general treatment. I would not buy this book unless it were very cheap. Take a look at it at the bookstore or borrow from a library, but don't spend your money.To people wanting a general treatment about concurrency, it's principles, problems and solution space, I recommend \"Concepts, Techniques and Models of Computer Programming\" by Peter van Roy and Seif Haridi. It's thoroughly educational, and half of it is about concurrency (but no specific treatment of pthreads, PVM or MPI).",
                "review/helpfulness": "12/13",
                "num_reviews": 13
            },
            {
                "review/text": "The title was ever so promising. But when I finally got to use this book,my disappointment was limitless.I found myself having to be on the lookout for errors of all sorts instead of learning from the book.While the book is in the 600s in the number of pages,it is rather thin on content on the topics that it covers. Take Chapter 4, \"Dividing C++ Programs into Multiple Threads\" for instance.The authors do a lot of hand waving explaining what is essentially threads in C (behind some little C++ syntax),and just when you are hoping to learn about threads in the presence of composition (as you might need with nested parallelism) or inheritance, you are met with section 4.11.5 \"Creating Multi threaded Objects\" that is only one and half pages long and tells you nothing you did not know already. The authors then proceed to add more than hundred pages in the form of appendix B on material that you can get off the internet.I've since decided to use Intel TBB (and bought Intel Threading Building Blocks by Reinders) for my project. With POSIX threads here to stay and parallel programming becoming mainstream,the authors ought to use subsequent editions as opportunity for great improvement.",
                "review/helpfulness": "5/5",
                "num_reviews": 5
            }
        ]
    },
    {
        "Title": "struts kick start",
        "description": "Explains how to build applications with Jakarta Struts, discusses the development framework and its architecture, and provides sample applications.",
        "authors": "['James Turner', 'Kevin Bedell']",
        "infoLink": "http://books.google.com/books?id=lNv8c_sjB8IC&dq=Struts+Kick+Start&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "Struts Kick StartI started learning how to use the Struts framework in late in 2001, after I became fed-up with hacking web applications together with the digital equivalent of &quot;Duct-tape Engineering&quot;. At that time there were no books available for the budding Struts developer, &quot;Read The Fine Manual&quot; was not an option ... you read the website, you read the code or you asked questions on the mailing list. This situation finally changed this fall with the release of a flurry of titles dedicated to Struts. I present here my thoughts on one of the latest: &quot;Struts Kick Start&quot;.What is Struts?Struts is a framework for developing web applications. It is a distilation of the current set of known best practices into a working code set that can be extended to meet almost any web application requirements. It part of the Jakarta Project at the Apache Software Foundation.What do I know about Struts?I have been developing web applications, using Java, for four years and using struts for over a year, and am a regular participant on the Struts mailing list. I was also a technical reviewer for one of the other Struts Books released this fall and was recently invited to speak at the University of Wisconsin, Eau Claire on the use of Struts.What's good about this book?There are many excellent things that I could point to. I particularly like the obvious depth of research that accompanies this book. There is a very interesting history of the development of the MVC design pattern and they even name the inventor. Do you know who invented MVC? If you want to know, buy the book!The chapters cover everything that you will need to know, in the order you are most likely to need to know it. There's even a chapter explaining the &quot;struts-config.xml&quot; file's DTD! (You may want to skip that on the first few readings :-)There is good coverage of the Struts taglibs. I see a lot of questions about these on the mailing lists, so this information is very timely and it looks very well explained.I like the coverage of other open source tools that work well with Struts. This is an important point because Struts does not do everything for you (by design), so there will be areas that will benefit from other tools. I'm looking forward to trying out some of their recommendations and easing my own Struts development lifecycles.What's not so good?Just one niggle, and it's more of a programming style issue, but in their example code they have references to their business objects. They explain that it is important to separate out business logic from action logic, which it is, but then proceed to use their business object within the action.Now, I realise that example code is not the same thing as robust, production-ready code, but when people are first learning a language or framework, they tend to copy exactly what they see in the book they are learning from. Even though example code should be light on error checking (for reasons of readabilty), it should be heavy on correctness and good style.Should you rush out and buy it?If you are about to use Struts on a project, are new to Struts and need dead tree documentation for those RTFM moments or are evaluating Struts for future projects, then you absolutely need this book.If you are an intermediate Struts user, then this book would still be very useful to you and I can certainly recommend it.If you are an experienced Struts user, then you've almost certainly exchanged emails with James or Kevin, on the Struts mailing list, so you can make your own mind up!",
                "review/helpfulness": "14/18",
                "num_reviews": 18
            },
            {
                "review/text": "I disagree with the other reviewers that are complaining about the example applications or lack of advanced features. I think books that have examples that are too complex or advanced get away from helping you learn the basics because the examples are too complicated to read quikcly when you are in a hurry. With Struts Kick Start, I can go right to the place in the book that explains the specific thing I'm looking for quickly.I've looked at all the available books on Struts and I own three of them. Struts Kick Start is the one I have found the most useful in helping me learn because it provides the best coverage of the basics of Struts and has many more coding samples for the struts tags than any of the others. The others refer you to the site for struts tags or just seem to replicate what is already on-line. Struts Kick Start explains each one in detail and gives sample code that you can cut and paste to use on your own. It also provides some great examples of unit testing and build scripts that I've been able to put to use without too much pain.This is a great, useful book.",
                "review/helpfulness": "10/12",
                "num_reviews": 12
            },
            {
                "review/text": "I bought this book to learn Struts: not to learn ABOUT struts. The authors clearly have a firm grasp on the topic, but unfortunately, this book is more of a 481 page example of them showing the reader what they know than it is instructing the reader in how to learn what they know. I have had this book for several weeks, and have read through many of the chapters before finally coming to the conclusion that this book is really quite worthless.For example, one of the main selling points for me was that Torque was covered - and even included on the CD. But when I got to Chapter 6, where Torque is discussed (all three paragraphs of it), it's such a &quot;high-level&quot; overview, that I'm no better off than when I started. Here's a quote from the book: &quot;After you've set up the XML file [the code preceeds this quote] and a property file [no code, no explination - what property file?] that tells Torque which database and connection pooling scheme to use, you use Ant [how?] to have Torque automatically use both the SQL files [which SQL files?] to create the database and the Java files to map classes to tables.&quot; p102. Do you see how vague and unhelpful this is?",
                "review/helpfulness": "9/10",
                "num_reviews": 10
            },
            {
                "review/text": "I'm totally surprised at the good reviews this book has been given. I purchased it based on those reviews and now ... well. The book is wordy and lacks some basic get you started information you would expect from a book with a title containing the words \"kick start.\" The authors got it part right - it should read, \"Start kicking.\" The authors seem to be upholding a long-standing java tradition: make it complex and avoid fundamental procedural steps. For what its worth, when I'm learning something new - upfront - I need to take baby steps - confidence builds and learning is accelerated on and up. Chapter 3 dives directly into a \"hello world\" application without one single word in the entire book devoted to \"Here is what you need to follow along boys and girls...\" Not one line of \"before we begin, do this and do that.\" So if your looking for a good text on \"guessing with struts\" look no more. I give it two stars because there must be some value somewhere in these pages.",
                "review/helpfulness": "8/9",
                "num_reviews": 9
            },
            {
                "review/text": "The Struts framework is becoming a de-facto standard for developing interactive web applications using servlets. If this type of development is something you are responsible for, you should consider getting a copy of this book to help you take the next step in your professional development. The \"kickstart\" concept means that the authors don't spend a lot of time on fluff or auxilllary material. You are quickly exposed to the core concepts along with a large number of examples to illustrate those technical points.There are a number of assumptions made in this book. The web server used for examples is the Jakarta Tomcat server. If you're using that platform for your development, you'll be very comfortable with the book. The authors also assume a prerequisite knowledge of JSP, as well as the use of MySQL for writing applications that access data from relational databases. From a cost perspective, this is all good in that you can set up your test environment for free. On the other hand, if you use other packages such as IBM's Websphere Application Server and DB2, you'll have to make the adjustments on your own.The book is very comprehensive in what it covers, and there is an abundance of code to help you see working examples that you can use for your own purposes. Since I'm not as \"up to speed\" on servlet technology as I'd like to be, I'd prefer a somewhat slower style for learning. But that's not a knock on the book as much as my own personal preference.ConclusionIf you're comfortable with web applications, deployment, and servlet coding, this will be a good choice for getting started with Struts. If you're still relatively new to all this, you may want to get a book that doesn't assume quite so much to start with. Once you get familiar with Struts, this would be a good companion book for examples.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "This book fills a major gap in the Struts literature: it shows you how to solve real-world problems using Struts. If you want to learn the details of how Struts works, you need a different book. However, if you're sick of wasting an hour every time you need to figure out how to use an html tag you've never used before, this is the book for you.I'm learning Struts so I can use it to write a commercial application. I didn't buy this book until I had finished the first two modules of my app, and I really regret it. I remember wasting 3 hours one day figuring out how to use &lt;html:select&gt; in conjunction with &lt;html:optionsCollection&gt; to render a lookup table from my database. I'm pretty handy with Google, but the fact is, there's not a lot of solid information out there about how to use the Struts tag libraries. This book contains the exact code I needed - I could have copied it into my JSP and been on my way in less than a minute.It's obvious to me that Turner and Bedell struggled through Struts the way I did, and decided to write a book with all the answers once they figured the answers out. They did a fantastic job. They cover all the aggravating details you're going to face writing real apps, and they explain the solutions clearly and accurately.Bottom line: After reading the three major Struts books, I can tell you that none of the books alone will get you where you need to go. I recommend &quot;Programming Jakarta Struts&quot; for learning Struts theory, and this book for learning how to get real work done.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "This was the first book that I bought in order to learn Struts. I found that the text was generally unhelpful as it was written from the point of view of Struts 1.0x, whereas 1.1 invalidates much of what the authors talk about (you might as well rip out the chapter about validation and throw it away, because NOTHING in there is valid), assuming it wasn't bug-ridden anyway.The supporting website hasn't been updated since May, 2003, and the links to updated files are all dead (the chapter 3 hello program on the CD doesn't work, so you're SOL now).The ONLY saving grace is the CD.I suggest you look elsewhere for an introductory book; this book seems to be hacked out quickly to capitalize on the Struts phenomenon and just as quickly abandoned.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "First, this book was published in 2002, which means it was written in 2001. Rather out of date.I have three very major complaints.1. The author, like almost all Struts book authors, starts right off the bat giving examples of JSP files that include Struts tags...a topic that is not covered until many chapters later! So the beginner (me) is left scratching his head wondering what all this gibberish is about. How much easier it would have been to provide the early examples in HTML and then later show them using tags AFTER tags have been introduced and discussed.2. There are l-o-n-g sections of nothing but HTML/JSP code with almost no commenting. Do ANY publishers get it that they don't need to print EXACT code listings? The printed page could have arrows and circles and bold print highlighting codes snipets and discussing what they do. This book leaves it up to the reader to find the important nuggets in hundreds of lines of code.3. Certain sections are so terse as to be meaningless, and even go so far as to tell the reader to look at the Struts documentation and then you'll understand it all. HELLO?? That's why I bought the &%$#!! book.On the plus side, the font is nice, there is plenty of white space and it is easy on the eyes.Skip this one. This is my 5th Struts book and I'm STILL looking for a good one. I think a good rule is that if a book is written by an open-source code author, avoid it like the plague. Coders are NOT writers. Unfortunately, the editors don't seem to be writers either. Maybe that job was outsourced...",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "I would highly recommend this book for anyone looking to get a practical, working knowledge of Struts in a short amount of time. It also gives clear advise and recommendations on design issues and technology choices not only for using Struts and JSPs, but also on integrating with back-end databases, Enterprise Java Beans systems, and Web Services systems.The book develops a practical Struts application, including database integration, that walks through all the real world development stages from design to deployment, highlighting best practices and key issues at each step. While doing all this, the book is brief and to the point. This keeps it fast moving and interesting while providing a useful working knowledge of Struts. The authors provide clear recommendations on manyissues. Design or technology options that exist at various points are highlighted and the trade-offs identified, but the authors do not get bogged down in technical digressions at these points, but rather state their recommendation with their reasons and then refers to other resources for the reader who wishes to delve into the issues further.In addition to the basic Struts application, the conceptual background is clearly laid out and chapters on the details for all the Struts tags are provided. Another highlight of the book are the chapters on advanced topics of integrating Struts with Enterprise Java Beans and with Web Services. In a brief amount of space, these chapters walk through all the steps to set up and run an example application that can serve as a model for real world development. Again, all the key design and technology decisions are highlighted and explained.A big plus with this book is that all the example applications and the technology products needed to set them up and run them are included on the CD that comes with the book, so you can be sure you are working with the exact same software and setup that is documented in the book.",
                "review/helpfulness": "4/4",
                "num_reviews": 4
            },
            {
                "review/text": "When I am writing this review, the price of a used copy starts from 56 cents. You can imagine what quality you can expect from a book whose owner is so eagerly willing to part with it.I did read this book and here is what I have to say. In short, do not buy this book or even read it. It's a waste of time.I can't believe Craig McClanahan recommended this book. How much did Sams pay him to say that?",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "embedded internet design tab electronics technical library",
        "description": "*Explores how to make microcontroller systems that are Internet-active*Covers both Java-enabled modules and stand-alone microcontroller designs*An excellent introduction to web technology basics for hardware designers.",
        "authors": "['Al Williams']",
        "infoLink": "http://books.google.com/books?id=c0eSJVzbE74C&dq=Embedded+Internet+Design+(TAB+Electronics+Technical+Library)&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This book provides excellent examples of linking TINI and Javelin-based systems to the Internet; however, the title (\"Embedded Internet Design\") is slightly misleading. The book discusses connecting two specific embedded systems (TINI [website] and Javelin [[website]]) to the Internet. It does not deal with designing embedded Internet-aware systems, nor does it deal with embedded systems other than the aforementioned two - except in abstract terms. However, I suspect that most people looking to buy this book are interested in exactly what it discusses and won't buy it believing that they will learn how to design embedded systems. I'm not even sure what \"Embedded Internet Design\" actually means...The user is initially presented with an overview of how the Internet works and how to use Java, both of which are sufficient as an introduction, but readers who need to learn more about either subject would be well advised to obtain books dedicated to those topics. These introductions occupy about 1/5 of the book.The rest of the book does serve nicely as a cookbook for connecting TINI and Javelin-based systems to the Internet (i.e., connecting to POP servers, using UDP and TCP packets, etc.). Other reviews have mentioned a competing book for information on using TINI-based systems, and I haven't read that book as a comparison. However, the TINI section is certainly sufficient, as is the Javelin section. This book will show you how to use either chip to connect directly or indirectly to the Internet, and, if that's what you want to do, then you'll be happy with this book...with one exception. As mentioned in, I think, EVERY other review, this book LACKS ONLINE SOURCE CODE! To me, that's an unforgiveable sin, and drops a couple of stars from my rating.I bought this book because, as a professional Java programmer who is just now experimenting with hardware, I wanted to learn how to make my designs accessible to the 'net. I feel like I know how to do that now. However, as mentioned, I am very disappointed that I need to type in all of the code, which, by the way, seems to occupy about a fifth of the 318 pages of the book. That is a LOT of code to type in manually. It's great to have all of that code as examples; it just should be a matter of cut-and-paste to actually use it.",
                "review/helpfulness": "8/8",
                "num_reviews": 8
            },
            {
                "review/text": "If you are looking for a lightweight introduction to embedded internet this is not a bad book.If you have plans to internet enable your javelin stamp, this is your only source.But if you plan to use TINI to do the job, you will be much better off with the book &quot;Designing Embedded Internet Devices&quot; from NewNess press (ISBN: 1878707981).The book lacks a decent introduction to the TINI development environment. Also the source code is not documented at all. There is just a bit of wrap text around each code example, not explaining what is happening in the code.And if you finally want to use the source code you will have to retype it, cause there's neither a cdrom or a website of the book available.My advice (if not interested in javelin stamp): Buy the 'other' book !",
                "review/helpfulness": "3/4",
                "num_reviews": 4
            },
            {
                "review/text": "I think soon every device you can imagine will be internet enabled. This book is a good introduction for people like me that aren't internet gurus. It isn't really about the hardware. It is about the internet protocols and how to work with them using small hardware.Another review said it wasn't a TINI tutorial. That's true. It doesn't say that it is. You do need to RTFM this book is more about internet concepts and less about the specific tools although it uses the TINI and the Stamp thing. I don't have either of these chips yet, but the ideas were useful.That same review said the code wasn't well commented. That depends... there aren't a lot of simple comments in the code but I found comments where they were necessary. And the text in the chapter explains the code in a lot of detail. So if you are just skimming the listings, yes the code might seem hard to follow. But if you read the text the code is explained in great detail.I do wish the code were on a disk or on the net. I may buy a TINI or a Stamp and try some of the projects. If the code were available I'd have given it a 5.I'm about 1/2 through the book and how the internet works at a detailed level is much clearer to me now. If you want a good introduction to networking a micro you will enjoy this book.",
                "review/helpfulness": "3/4",
                "num_reviews": 4
            }
        ]
    },
    {
        "Title": "the evidential power of beauty science and theology meet",
        "description": "While everyone is delighted by beauty, and the more alive among us are positively fascinated by it, few are explicitly aware that we can recognize truth by its beauty and simplicity. Dubay explores the reasons why all of the most eminent physicists of the twentieth century agree that beauty is the primary standard for scientific truth. Likewise, the best of contemporary theologians are also exploring with renewed vigor the aesthetic dimensions of divine revelation. Honest searchers after truth can hardly fail to be impressed that these two disciplines, science and theology, so different in methods, approaches and aims, are yet meeting in this and other surprising and gratifying ways. This book relates these developments to nature, music, academe and our unquenchable human thirst for unending beauty, truth and ecstasy, a thirst quenched only at the summit of contemplative prayer here below, and in the consummation of the beatific vision hereafter.",
        "authors": "['Thomas Dubay']",
        "infoLink": "http://books.google.com/books?id=CCatd0e4jg4C&dq=The+Evidential+Power+of+Beauty:+Science+and+Theology+Meet&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "As the title suggests, this new book by Fr. Dubay is a wonderfully written and compelling argument for the power of Beauty as a primary evidence of the existence of Truth made evident in the handiwork of the Lord at every level of the created order. One of the most exhilarating books I have read in the past five years, Evidential Power makes the assertion that \"every experience of beauty points to infinity\".Fr. Dubay structures this volume in three sections. The first, \"Laying The Groundwork\", deals primarily with a theology of Beauty, establishing the place that Beauty holds in declaring the glory of God in every created thing. The important cornerstone that is laid in this section is that all beauty in the created order, both in the heavens and on the earth, derives its beauty from the \"radiant form\" of the Person of Jesus Christ, Who is the express image of the Beautiful God. As human beings created in that image, we are made to resonate with the form of that which is beautiful, and we find ourselves captivated by beauty wherever we see it. All things have beauty in proportion to their conformity to the radiant form of Jesus, and ugliness, or deformity, emerges when the radiant form of Christ is denied or lost.Fr. Dubay suggests three levels of common understanding of beauty: the comeliness of the appearance of something lovely on the sense level, the spiritual beauty of a person who has begun to transcend the natural realm through the consideration of higher things, and the beauty of Divine glory, which is the pinnacle of Beauty. All these levels find their meaning in relationship with (conformity to) the classical principle of Beauty, that which has unity, harmony, proportion, wholeness, and radiance. These qualities are found in perfection in the Trinitarian Godhead, in the beautiful and radiant relationship between Father, Son, and Holy Spirit. As the first section proceeds, Fr. Dubay gives expression to the questions of how and why we are impacted by that which is beautiful, and the destiny that is in the heart of God as He draws us by the power of Beauty.The second section of the book, \"Savoring The Symphony\", is given over to the examination of how Beauty is expressed specifically in the created order. The author begins with the realm of non-human beauty in \"macro-marvels\" (the cosmos, stars, planets, and galaxies, etc.), \"midi-marvels\" (the world of plants and animals), and \"mini-marvels\" (the world of the microscopic). Focusing on the marvelous design of the created order, from the biggest to the smallest, Fr. Dubay leads us on a tour de force of intricacy, intelligence, and purpose rooted in the mind of God as He painstakingly fashioned the cosmos.This section culminates in an overview of \"the anthropic principle\", an emerging scientific theory that deals with the inescapable conclusion that the whole universe was designed in a precise way so that human beings could live upon the earth in a very narrow window of time. Moving from this to a discussion of humankind as \"the crown of the cosmos\", the author shows that the creative power of God finds its highest expression in the creation of human beings as His own special treasure. This truly is a mind-boggling section of the book, as the author gives example after example of the intricacy with which God designed the whole thing so that we might live and have relationship with Him.The final section, \"Divine Glory\", deals more specifically with Beauty as it is found in the Divine Personality, expressed in the radiant image of Jesus Christ, and as it emerges in those who give themselves extravagantly to the pursuit of holiness and beauty. This radiant beauty, or reflected glory, shines forth in proportion to the whole-hearted gazing upon the Lord Jesus in worship and contemplative prayer. As one would expect, Fr. Dubay's Catholic orientation is obvious here, but in a compelling way. As he cites the examples of the saints of the Church who have given themselves lavishly to this pursuit, it is difficult to argue with the results: the saints have lives that have reflected the character and beauty of Christ both in the personal realm, and in the realm of ministering to humanity in His Name.For those who have a painful history in the Catholic Church (and what person who has been in any organized denomination for very long has emerged totally unscathed?), Fr. Dubay's enthusiasm may seem a bit much. However, the argument is solid: when we examine the lives of those who have given themselves in unrestrained ways to loving God, the fruit of their existence is self-evident. This reality is perhaps the final and most substantial proof that the thesis of the book is valid: there is an evidential power in Beauty, and we are blessed that Fr. Dubay has seen fit to instruct us.",
                "review/helpfulness": "82/84",
                "num_reviews": 84
            },
            {
                "review/text": "This book is truely wonderfull. My journey with God has always been an interesting one and lately it has been a surprizing one but Thomas Dubay has helped me to understand a deep part of God's call to be that I did not really understand until I read this book.I have always been fascinated by science and nature but lately in my work with the elderly and with prisoners in the criminal justice system as well as my growning sprituality which includes contemplative prayer. Thomas Dubay's book has helped to to understand how both of these aspects of my walk with God tie to my early appreication of science and nature.I have also developed a great appreciation for Han Hurs Von Balthasar from this book.Thomas Dubay is a truely gifted writer and I hope to see many more of his books in the future.",
                "review/helpfulness": "22/24",
                "num_reviews": 24
            },
            {
                "review/text": "I can't say enough about this book to do it real justice. Evidential Power of Beauty has not only opened my eyes, mind, and senses to creation on a deeper level, but it has intensified my hunger and wonder that is often stifled and desensitized in American pop culture. Though one reviewer commented on Dubay's \"attack\" on rock and roll, I don't believe it was an attack at all. Quite the opposite. Dubay simply made a point about why certain types of music produced harsh, often filthy, shallow repetitive melodies, while others, such as Mozart, produced a more complicated, pleasing piece that required the best of the mathematical beauty and design he discusses throughout the book. It was just another comparison of the beauty of complicated design versus simplistic noise. However,I can give Dubay grace in that area, as I must allow for his lack of knowledge for a band such as YES (very complicated, very beautiful pieces of music)often categorized as \"rock.\" (Though quite a different caliber than,say,Ozzy Osbourne.)I give Dubay a break on that facet of the book.I am not a scientist,a theologian, or a Catholic. You don't have to be to enjoy this book immensely and even learn a thing or two about something you probably never thought twice about--for example,water. Dubay takes time to explore the \"givens\" in our world that are so casually seen as \"miraculous accidents.\" His marvelous prose and fire for God lights every page. The underlying push for even beginning to ponder God's mystery,awe, and love is, as Dubay quoted, the \"ability to have the humility to sit at the foot of a dandelion.\"The book is simply a masterful work of art, a lovely tour of how theology and science merge together at the point of Beauty. Though both disciplines have opposite starting points, they lead to many of the same conclusions about our Universe.Buy or borrow this book, find a comfortable chair, and take your time absorbing the \"evidential beauty\" in this book.",
                "review/helpfulness": "20/21",
                "num_reviews": 21
            },
            {
                "review/text": "The author's thesis is simply distilled and has often been an overlooked feature of the teleological argument for the existence and nature of God: not only that design is evidence of intelligence and will, but that beauty is evidence of truth. Catholic theologian Thomas Dubay illustrates the connection between beauty and truth. Physicist Richard Feynman said, \"You can recognize truth by its beauty and simplicity.\" Einstein regarded the beauty of a physical theory as a proof superior to empirical evidence. Mathematicians have long regarded the beauty and elegance of an equation or mathematical expression as the most necessary indicator of its truth. We have come to realize that nature is ultimately mathematics, beautiful mathematics (Plato was right). Why is reality, at its core, beauty? Whether the equations that describe the deepest features of the quantum world, the fine tuning of the cosmic initial conditions, the highly specified organization of microbiological cell \"cities\" (we could go on and on), nature is all about beauty. What does this indicate to the uncallused observer? And what then is the evidential power of ugliness? Dubay contrasts the two contending worldviews: materialism (existence is a meaningless and ultimately absurd accident), or theism (existence is intended, meaningful), concluding that the very ugliness of absurdity is evidence of the falsity of atheism/philosophical materialism.\"... simple observation shows that people, including academics, readily welcome intellectual interventions and therefore design, when the question is free of cultural biases and does not impinge on their personal lifestyle and chosen philosophy. I find it both amusing and instructive that when scientists come upon evidence in their field (anthropology, for example) that seems to support a theory popular among their colleagues, no one hints that an apparent causal connection was due to random chance. In an archeological dig, if the investigators find a stone so chipped that it could have served as a knife, they conclude that it was deliberately made, that is, designed for that purpose by a human ancestor. Their inference may well be true, but all the same, it is enormously weaker than design in a bird's wing, and fantastically weaker than design throughout any living cell. In the latter, the case for design is overwhelming. When it is rejected, the cause must be due to personal philosophy and bias having nothing to do with science. In more plain language, the rejection has all the appearance of a materialistic dogma that no divine mind must be admitted. This is bad science because it is a position based on a personal philosophy and not on scientific data. The carefully arranged and massive blocks of stone at Stonehenge are a more detailed example of a scientific acceptance of design when such is popular. Their precise positioning is explained, most likely correctly, by the deliberate will to align them to the sunrise at the summer solstice. This likelihood seems stronger than that of the chipped stone, but it remains far, far weaker than the endless examples nature furnishes ... Yes, something less than cool, objective scientific thinking lies behind the rejection of mind behind nature.\"The science here isn't always precise, but where it is not it seems that Dubay has understated his case. Thus the discrepancies do not damage the author's thesis. The greater flaw to this volume is that the author has presented not only an apologia for the reality of a wise Creator but for the Roman Catholic Church. Cases against atheism suddenly incorporate attacks on Protestants, rock n roll, contraception, etc. If the book had been edited into something more lean and 'on-task' this would be a tremendous book. It's pretty good as is.",
                "review/helpfulness": "16/18",
                "num_reviews": 18
            },
            {
                "review/text": "Great book--doesn't completely overcome my doubts about God, but comes close. Everyone should read the chapters on the maxi, midi, and mini marvels we come in contact with every day.",
                "review/helpfulness": "5/5",
                "num_reviews": 5
            },
            {
                "review/text": "My mother gave me Dubay's book since she knows that science and theology, and their constant intersection, are things I, as a physician and a Puritan, constantly engage both theoretically and practically. As such I was eager to read this book and found it most enjoyable, generally well written, although sometimes I think his assertions and conclusions unknowingly beg the question of Christian faith, and typically theologically sound. I must say upfront that whenever Dubay would delve into the realm of that which is specifically Roman Catholic in doctrine - particularly discussions of Mary, the Saints (vs. the saints), his treatment of sanctity vs. sanctification, his description of the nature of the church, and his adherence to the Pelagian error - I found it disturbing to my Reformed sensibilities. Having said that, I would plainly recommend this book to an informed and doctrinally sound Protestant Christian who has a discerning theological filter, but would be less likely to recommend it to a more spiritually immature or nave Christian. If one is Catholic, they are used to these things and probably embrace them.Let me briefly begin with faults because I want to concentrate on the book's many strengths:1. Again, from my Reformed perspective, the plainly Roman Catholic doctrines I previously mentioned and a few others.2. The treatment of Science and theology as separate, independent, self-evident co-equals. Theology is derived from the inerrant scripture and is the benchmark of all truth since it is the breathed Word of God and therefore must be above science which is derived from broken groaning nature and flawed human reason, both corrupted by Adam's rebellion.3. A generally uncritical acceptance of evolutionism, and even a criticism of creationism, without a serious discussion. There are many resources to counter this: Nancy Pearcey's Total Truth does this well when presenting the importance of Christian world view, Michael Behe, William Dembski, the Discovery Institute, etc.4. The insistence that current biological forms are \"perfect in their kind,\" which is antithetical to a belief in any kind of evolutionary logic.5. His drift toward universalism, the idea that we are all \"children of God.\" Only those in Christ are God's children, the others are our neighbors, not our brothers and sisters. This is further evidence of the Pelagian error.6. His beef with rock and roll and his blind affection for classical music. He criticizes rock as essentially brutish, and much if it may be, but consider Queen's Bohemian Rhapsody, consider Rush, Fates Warning, Dream Theater, Yes, among many others. Conversely, there are many \"classical\" music pieces that are grossly secular in their themes - sex, drinking - that it cannot be established as pure. The issue is skill, content and context, not musical style.The strengths, in brief summary, because they are many and profound:1. The single most important strength of this book is the exaltation of the beauty, splendor and glory of God manifest most graciously in Jesus Christ and Him crucified. This book has greatly encouraged and exhorted me to love Jesus more, and more as beautiful. Dubay's emphasis on Jesus can be summed in this quote he has from Hans Urs von Balthasar, his primary resource: \"It is not sacred scripture which is God's original language and self-expression, but rather Jesus Christ. As one and Unique, and yet as one who is to be understood only in the context of the whole created cosmos, Jesus is the Word, the Image, the Expression and the Exegesis of God.\" That is beautiful.2. The overwhelming emphasis on love. \"There is a great need to reunite what God has joined together...intellectual competence and burning love - which is to say that the beautiful must be a prime part of the biblical and theological enterprises.3. Numerous beautiful, well explained examples of the design inferred from nature, 5 chapters specifically devoted to micro-, macro-, and midi-marvels, the anthropic principle and artistry in nature.4. The exhortations to holiness, derived from God's holiness, reflecting Christ's holiness, and observing glory as \"holiness manifest\" in the sublimity of creation. If one were to argue about the errors in the system as a result of sin, he has a chapter on Ugliness, specifically dealing with that.5. An emphasis on Trinitarian theology in the expression of God's character in creation.6. The idolatry inherent in modern science as expressed in scientism. \"We must have something to focus on, to glorify, to worship. We either pursue the real God or a created surrogate.\"\"People who love reality, love truth...being men and women of integrity, they treasure beauty because it is the mark of truth.\"Overall, this was a wonderful book that moved me to love my Savior more.",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            },
            {
                "review/text": "I've just began reading this book and couldn't put it down. As an artist, i think it is important to know the principles of beauty. I also watch the show of Fr. Dubay based on the book in EWTN. I recommend this book to anyone fascinated about Beauty, that ultimately points to its Divine Author. :)",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "symbolicc an introduction to computer algebra using objectoriented programming",
        "description": "Symbolic C++: An Introduction to Computer Algebra Using Object-Oriented Programming provides a concise introduction to C++ and object-oriented programming, using a step-by-step construction of a new object-oriented designed computer algebra system - Symbolic C++. It shows how object-oriented programming can be used to implement a symbolic algebra system and how this can then be applied to different areas in mathematics and physics. This second revised edition:- * Explains the new powerful classes that have been added to Symbolic C++. * Includes the Standard Template Library. * Extends the Java section. * Contains useful classes in scientific computation. * Contains extended coverage of Maple, Mathematica, Reduce and MuPAD.",
        "authors": "['Kiat Shi Tan', 'Willi-Hans Steeb', 'Yorick Hardy']",
        "infoLink": "https://play.google.com/store/books/details?id=UDb0BwAAQBAJ&source=gbs_api",
        "review": [
            {
                "review/text": "You will find this book fascinating if you are a computer science student intrigued by symbolic calculation systems such as Mathematica and Maple, and if you would like to see how such systems would be implemented in C++ (Mathematica and Maple are actually implemented in plain old C).The C++ level required is just after CS2, the second C++ class that comprises data structures. If I were a CS2 instructor, I guess I would require students to read some parts of this book since it is a great means of reinforcing about all the concepts learned in C++, while building a nontrivial application; although some examples are taken from physics, physics knowledge is by no means required and the general math level called for reading this book remains comfortably low, and one can always skip the things one does not know or does not care about (such as quaternions, but hey, some people might be turned on by that stuff...).It shows how to build classes that actually perform calculations using integers of arbitrary length, rational numbers of the a/b form, vectors, matrices, quaternions, symbolic variables, differentiation, integration, etc.The system described in the book, SymbolicC++, can be used as a FREE alternative to Mathematica or Maple, less of course the graphing capabilities these great software products offer (less also zillions of functions available). SymbolicC++ may nevertheless be connected to Gnuplot to produce graphs. SymbolicC++ may also be of interest to the professional developer having to struggle with complex calculations, since its classes can be included in any C++ environment.So in short, this book is great if you have the right background and the right interests.I should also point out that Dr Steeb has written another great book that shows the system at work in problems from the physical sciences and finance (&quot;The Nonlinear Workbook&quot;)",
                "review/helpfulness": "10/13",
                "num_reviews": 13
            },
            {
                "review/text": "A mixture of C++, group theory, and mathematical physics. Far from a polished treatment, but maybe worth perusing if these are topics of interest to you.",
                "review/helpfulness": "4/6",
                "num_reviews": 6
            }
        ]
    },
    {
        "Title": "data structures and program design in c",
        "description": "Programming Principles 2 Introduction to Stacks 3 Queues 4 Linked Stacked and Queues 5 Recursion 6 Lists and Strings 7 Searching 8 Sorting 9 Tables and Information Retrieval 10 Binary Trees 11 Multiway Trees 12 Graphs 13 Case Study: The Polish Notation Appendix A Mathematical Methods Appendix B Random Numbers Appendix C Packages and Utility Functions Appendix D Programming Precepts, Pointers, and Pitfalls Index.",
        "authors": "['Robert L. Kruse', 'Robert Leroy Kruse', 'Alexander J. Ryba']",
        "infoLink": "http://books.google.com/books?id=t2gPAQAAMAAJ&dq=Data+Structures+and+Program+Design+in+C&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "The previous Pascal edition of this book was extremely readable and what I learned data structures from. It had a lot of diagrams which were invaluable to understanding the algorithm. This book improves upon that edition by adding even more illustrative pictures and is updated with new algorithms and analysis techniques like amortized analysis which were not around when the old book was written. The writing style of the author is impeccably understandable. I collect books on algorithms and data structures and this is the most readable book ever.P.S. I've found the books which use STL to be opaque and focus more on STL and C++ than on understanding the data structure and algorithm. This is why many authors, including Sedgewick, eschew STL in their books. STL is also not relevant when programming in other languages, like the ubiquitous C programming language.",
                "review/helpfulness": "6/9",
                "num_reviews": 9
            },
            {
                "review/text": "This book is unfortunately not worth the price to pay. I had the misfortune of buying it because it was required for a data structures class at my school. My main problem with it is that it does not use the STL versions of the classes in the book. The author writes his own versions that do not conform to the standard. This presented a large problem when I went to use the concepts from the book in a program. I got tons of compiler errors until I finally got mad and looked up the STL version documentation. To my surprise, this book uses different function names and different function signatures in many cases. I would say that it is a decent book for learning the concepts, but as far as using them is concerned, you'll need to look elsewhere.",
                "review/helpfulness": "5/8",
                "num_reviews": 8
            },
            {
                "review/text": "I just finished an online course on data structures at UMass, Lowell (secured an A grade without any problem) and this is the textbook used for this course. I agree with some of the comments made by the reviewers here - that typedef's are used beyond reason, code is presented in fragments. I must strongly disagree with the reviewers who said - the book is not worth the money (it's cheap if you buy a used one), it is a bad book, useful only as a paper weight. The strong plus point for this book is that it presents theory well - there are many figures using which it is easy to understand complicated stuff. The other plus point is that it also analyzes the performance of algorithms and I felt the book does a great job of explaining this part in clear terms. The main drawback is that the code is fragmented and spread out, which is certainly frustating. Also, in order to get the code to work on a compiler (I used Microsoft VC++ version 6), you will need to \"fill in the gaps\" as most code examples (I tried 90% of the examples in the text on MVC++ compiler) are by no means complete but this was not difficult. You can download the code from the publisher's website and the code is actually not organized into different files (sorted by chapter and example) but it comes in a few files where examples from different chapters are mixed. You will have to search and find the part you need. I do agree usage of dummy functions creates confusion. This book has a rocky start with the life game example, which was not very easy to follow with the explanation provided. While I was frustated with the first two chapters, the rest of the chapters are presented well. To the reviewer who said that the code has bugs (which certainly isn't true), my guess that the gaps are not properly filled. I patiently tested most of the code on the computer (after filling in the gaps of course!) and find absolutely no problems with it. This however took lot of time since significant effort is needed from the student to fill the missing code to make it work. I have supplied working code to my fellow students who were facing difficulties in getting the code to run. In a couple of places in the text, the author surprised me with C syntax I did not know was legal (I consider myself intermediate programmer).I suspect the reason why many readers have problems with this book is two-fold: 1.The code is not available in a format that can be tested on the compiler. Having read a lot of CS books which supply with readily usable code, this book gets annoying. I was wondering why the authors did not give downloadable working code for all examples in the text (which is a definite minus point) 2. The reader will have to go back and forth between the chapters as some functions developed in former chapters are used in later chapters. This does get irritating. I have read books that do this to a ridiculous level but this book stays with in tolerable bounds.I will not rate this book as the best one on the subject out there but it is definitely good enough to learn data structures. I have used another book as a supplement: Data Structures & Algorithms in Java (Mitchell Waite Signature Series) (Hardcover) By Mitchell Waite, Robert Lafore ISBN: 1571690956. This book has lot of applets that show step by step how algorithms work. I am a visual learner and this helped tremendously. However, I felt that Waite Series book did not present the theory as thoroughly as Robert Kruse's text.In summary, I consider this book as \"decent\". I was very much concerned when I first purchased this text because of so many bad reviews. As it turns out, those that can understand C and are willing to sit in front of the computer to make the code samples in this book work need not have any fear. As I said earlier, the theory is presented well, and all it needs is patience and diligence from the student to go through the code examples on a compiler. I believe that I now have a good understanding of the subject and I can move on books that deal with it at more depth. There are a plethora books on this topic out there and there may be better books than the ones mentioned in this review.",
                "review/helpfulness": "8/8",
                "num_reviews": 8
            },
            {
                "review/text": "There is a number of books in Algorithm design which concentrate blindly on the run time complexity of algorithms, when covering them. This book is quite an exception to that tradition. In contrast, this book explain the algorithms itself. If you are interested to know about more detail and personalized characteristics of an algorithm, besides its running time complexity, such as space complexity, data movement complexity, performance on non asymptotic (smaller) case, etc. this is the book to read. Although, the book appears less technical at the first sight, I have compared it with Corman's. It contains almost all the analysis for the algorithms it presents. In fact Cormen's book lacks any analysis on space complexity. You will be disappointed in this book (like few other readers) if you are looking for a compendium of abstract complexity analysis of a large set of algorithms or just the discussion on data structure, pointer etc. It lacks advanced algorithms. Also, its graph theory chapter needs more depth. Without any reservation, I can say it is one of the best book available for first course in algorithm analysis and design.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "because of my limited english, i never write any review before. however, as i found this book,i feel that i must comment it for other's benefit. this book is the worst i ever studied. it's very confusing. after reading it, it only taught me to hate c programming.",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "com and corba side by side architectures strategies and implementations",
        "description": "Pritchard has experience in both the technologies that many consider competing architectures for creating distributed software solutions. He explains the strengths and weaknesses of each, noting that they have many other differences besides supporting different operating system platforms. He suggests when developers should one or the other. Annotation copyrighted by Book News, Inc., Portland, OR",
        "authors": "['Jason Pritchard']",
        "infoLink": "http://books.google.com/books?id=3-B4jq5RMisC&dq=COM+and+CORBA+Side+by+Side:+Architectures,+Strategies,+and+Implementations&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This is an amazing book which covers such a diverse field in distributed computing. This field is often confusing and sometimes even intimidating with many emerging technologies involving many programming languages and different platforms. Dr. Pritchard did an excellent job to bring much needed clarity in his book.The book has a very good organization and it is very easy to follow. It starts with a brief discussion on the history and background of distributed objects with some fundamental concepts. It then presents a comprehensive and objective comparison of COM and COBRA on both server and client sides. The book is completed with the presentation of bridging techniques between COM and COBRA, enabling the two to interoperate and coexist in an enterprise system. Dr. Prichard apparently has applied both COM and COBRA in practical projects, and therefore he is able to share his past experiences in using these technologies. He offers many technical insights in the planning and assessment, design and architecture, as well as implementation details with code examples in C++, Java and VB. I enjoyed reading his strategy discussions the most. There are too many books on the market which are filled with codes and technical details. This is a rare book which puts an equal emphasis on planning and design strategies.This book covers a variety of topics such as: MTS, MSMQ, ADO, ASP, OTS, JavaBeans and Enterprise JavaBeans, just mentioning a few. Dr. Pritchard presents these topics in a concise yet clear fashion. I am truly amazed that he could present all these topics with such a clarity, illustrating his deep understanding on the subject. It is certainly a book to keep for anyone who is working on or planning an enterprise distributed object system with either COM or COBRA.",
                "review/helpfulness": "11/12",
                "num_reviews": 12
            },
            {
                "review/text": "This book is quite thin, and yet it includes so much. The open mind towards competing technologies is important, we should all look at facts in an objective way. The book gives an excellent view on COM, CORBA and the differences between them. It also shows programming examples (not in depth) and explains things like &quot;push&quot; technologies very good. I would expect the first book in this subject (side-by-side approach) written by a technician, to be too detailed, with a poor language and not very educational. I was very wrong. An amazing book!",
                "review/helpfulness": "9/12",
                "num_reviews": 12
            },
            {
                "review/text": "Not only did &quot;COM &amp; CORBA Side by Side&quot; did an excellent job of comparing COM &amp; CORBA, it laid out a number of strategies to apply *both* technologies' strengths in designing and implementing your distributed system solutions. As Part 1 of the book is aptly titled, the book's overriding theme is embracing COM &amp; CORBA to your advantage. Evolutionary background and current technology trends in distributed computing were covered thoroughly. Development issues on both client &amp; server sides were given enough treatment to satisfy 2 groups of audience: developers who want to understand the implementation details &amp; differences of COM &amp; CORBA, and decision makers who need strategic information on the technology's main players and future directions.However, the key to the entire book is Part 4 that covers COM &amp; CORBA bridging strategies ranging from custom approaches (C++, JVM) to third-party commercial products (Visual Edge's ObjectBridge) to enterprise application servers that provide support for client &amp; server components implemented with both COM &amp; CORBA. This is probably the only COM &amp; CORBA book currently available that provides comprehensive information on this topic. My only complaint is that only one commercial bridging product was covered in this section. I wish the author had spent more time on other third-party bridging solutions. Well, maybe that can be covered in a second edition.The book is also logically laid out with executive summary before and after each chapter and major section. What I also like about the book's presentation is the example code are higlighted with light gray background, making it easy to distinguish between text &amp; programming details. In all, it is refreshing to come across a book that promotes building solutions by harnessing the strengths of competing technologies and does a very good job at that with real code &amp; examples.",
                "review/helpfulness": "11/11",
                "num_reviews": 11
            },
            {
                "review/text": "If you're in the process of architecting a new system or planning to rearchitect an existing system, this book will prove invaluable in helping you evaluate the strengths and weaknesses of each approach. Even if you're just interested in both technologies and want to dig deeper into each, this book is a sure bet!",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "A concise and comprehensive analysis of two technologies that are not necessarily mutually exclusive. Mr. Pritchard did an excellent work of dissecting each one and at the same time, achieved a perfect balance between theory and code examples that is so rare on this field. If you need to decide between COM and CORBA on your next eBusiness or back-office integration project, this book will set you on the right path.",
                "review/helpfulness": "4/6",
                "num_reviews": 6
            },
            {
                "review/text": "This book is quickly becoming one of my favorites because it is helping me decide between using COM or CORBA in our future product line. I know COM fairly well but didn't know CORBA, thus this book is helping me immeasurably. Talk about perfect timing! Using this book I am can compare the architectures as advertised- but I can also get a feel for the coding effort involved by using the code samples supplied. This was been an unexpected bonus and will allow me to prepare the development teams for whatever path I take. I have recommended your book to others in the company and it is now required reading for my architecture team.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "Though not explicitly meant to be this book might also serve as an introduction to both CORBA and COM: quite an achievement. The authors waste no words and keep a neutral standing between the poles. I hope the next edition will contain some information about Microsoft.Net too.",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            },
            {
                "review/text": "After reading most of this book it is clear that the author has significant practical experience developing solutions with both COM and CORBA technologies. This is a pleasant change from the theoretical emphasis in the several books on each of these subjects. It seems many of these are by professional writers, trainers or technology evangelists, and others are sponsored by technology development organizations.I like the very clear way that Dr. Pritchard imparts real world insights into engineering with both COM and CORBA. The comparisons of different aspects of the technologies are well presented in a (for once) unbiased manner. The code examples, which are in VB, Java and C++, are well thought out and clearly illustrate the issues under discussion. Also the organization of the book into client, server, and bridging sections adds to its overall readability.This is not an entry-level developer textbook, but for those familiar with one or both technologies it is great for understanding the relative benefits of each technology. It has lots of tips and helpful insights, and addresses some issues that hadn't occurred to me before.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "convex optimization",
        "description": "A comprehensive introduction to the tools, techniques and applications of convex optimization.",
        "authors": "['Stephen Boyd', 'Stephen P. Boyd', 'Lieven Vandenberghe']",
        "infoLink": "http://books.google.com/books?id=mYm0bLd3fcoC&dq=Convex+Optimization&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "This is an absolutely wonderful work on the subject. It delivers precisely what the preface promises -- a very comprehensive introduction to convex optimization for users. Moreover, it delivers far more, for it is incredibly well-written and unusually accessible. It's a joy to read.",
                "review/helpfulness": "20/28",
                "num_reviews": 28
            },
            {
                "review/text": "The book provides sound theoretical basis in a non-intimidating way. It also presents many examples that help the reader understand and relate his or her specific needs to general convex optimization problems. I think this book is a really good compromise between theory and practice: it can please the more mathematics-oriented with proofs, definitions, and bibliography; as well as the more application-oriented with examples, implementations, and heuristics. The authors have been very generous in allowing the free download of the full book from their website.",
                "review/helpfulness": "23/25",
                "num_reviews": 25
            },
            {
                "review/text": "Quite simply, this is a wonderful text. Coupling this with Boyd's course at Stanford (the lecture videos, HWs, etc. are all available for free online), you're bound to learn quite a lot about optimization. But most importantly, you'll have an idea of when you can actually apply convex optimization to solve a problem that comes up in your particular field.My reasoning in giving it such praise is my preference for the rather unusual methodology it takes in introducing you to optimization. Most books I have seen on linear programming or non-linear programming tackle a few standard problems, introduce what is necessary in terms of definitions and proofs, and then focus on the algorithms that solve these standard problems (conjugate gradient et. al.), how they work, their pitfalls, etc. While this is undoubtedly useful material (which Boyd does cover for a good deal in the final chapters), the simple fact of the matter is these algorithms are available as standard methods in optimization packages (which are abstracted from the user), and unless you are actually going into developing, implementing and tweaking algorithms, this quite honestly is useless.What this book attempts to do, and does very well in my opinion, is to teach you to recognize convexity that's present in problems that are first glance appear to be so incredibly removed from optimization that you might never consider it. This book spends the first 100 pages or so just devoted to building a \"calculus\" of convexity, if you will, so that you know through what operations convexity is preserved, and you develop intuition as to the potential to use convex optimization in problems in your particular field or application. As such, the first part of the books is focused on building up the skill set, the second part to applications of convex programming, and only the third to the actual algorithms.A word of warning: some of the explanations (especially in Chapter 4 which focuses on types of convex programs and equivalence of programs) are very general, which won't be satisfying to certain readers who need solid examples to reinforce the concepts. Also, a lot of the material can be quite challenging, requiring a bit of mental gymnastics. However, if you are accompanying your study with the problems at the end of each chapter, you're certain to get practice and demystify the concepts.In sum, all things considered, a great text.",
                "review/helpfulness": "24/24",
                "num_reviews": 24
            },
            {
                "review/text": "I think this is the best book for getting into optimization. It's simple with many examples and figures. Excellent choice for engineers, mathematicians might find it incomplete, but what can we do, that's life. I think the interior point section could have had more, but it is still ok. The next step after this book is Nemirovski's book \"Lectures on Modern Convex optimization\". You can download it for free from his website http://www2.isye.gatech.edu/~nemirovs/ along with many other notes. Nemirovski's book is very complete and has very modern ideas new to many engineers. But as I said Boyd's book is where you should start from. From an engineer's perspective I believe Boyd's book is much more easy to read and understand than Bertseka's bookConvex Analysis and Optimization. I also appreciate Boyd's courtesy to have his book available on-line for free. I bought the book after downloading it because it is worth its price. Try also another book coming from Stanford, which is more specializedConvex Optimization & Euclidean Distance Geometry, also available on-line",
                "review/helpfulness": "19/20",
                "num_reviews": 20
            },
            {
                "review/text": "The book excels in readability and style. A perfect balance on the theoretical and practical aspets of the convex optimization. As the name implies, and also as the authors put in preface, it is about recognizing, formulating, and solving convex optimization problems. Provides necessary mathematical background in the first part---not as deeply as a gradute level convex analysis book---and therefore helps reader build a working knowledge. If something is not covered in this part but essential for a working knowledge, then it is in the appendices for sure. Provides a wealth of examples, exercises, and applications. Perfect for self-study as well as classroom use.",
                "review/helpfulness": "11/15",
                "num_reviews": 15
            },
            {
                "review/text": "Well written and intuitive. Check out the online copy by following the link from the convex programing page on Wikipedia.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            },
            {
                "review/text": "This book trains you to recognize convexity, gives you the associated tools, also has a few chapters on the details of the tools. You will also end up knowing what to do when your problem is not convex. Coupled with Boyd's lecture videos and slides, it is an excellent place to learn about convex optimization for an engineer.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            },
            {
                "review/text": "This is an excellent text on optimization. The pdf version is free on the net. First I got the pdf version, I like the writing style and the way authors have described the concepts. Then I ordered the hard print. The print quality is excellent and its a great book to have!",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "code reading the open source perspective v 1",
        "description": "CD-ROM contains cross-referenced code.",
        "authors": "['Diomidis Spinellis', 'Ross Ross Venables']",
        "infoLink": "http://books.google.com/books?id=pqw2U-lI5lwC&dq=Code+Reading:+The+Open+Source+Perspective+(v.+1)&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "Programmers need to be able to look at code and analyze what it does in order to change it or fix it. The concept behind this book is to use many of the open source code samples to discuss how to read code and how to spot potential trouble areas in code. Unfortunately the book doesn't stay focused on this single goal and that detracts from its overall value. The book spends too much time explaining the basics of programming instead of concentrating on reading code. It also bounces around from one language to another, from C to C++ to Perl to Java, which is very confusing. For example, if you are a Java programmer do you really care how the C compiler optimizes strcmp calls? And what does that have to do with reading code?Some of the advice is fairly basic such as try to realign indentations properly and replace complex code structures with simple placeholders when doing analysis. Although there are parts of the book that are excellent, too many of these good parts are wrapped under what should be basic concepts to anyone reading code. How can you debug a Java program, for example, if you are unfamiliar with abstract classes, libraries, or polymorphism? Do you really need a book on code reading to explain basic object oriented programming?Overall, the book seems very unfocused and I really can't recommend it.",
                "review/helpfulness": "61/78",
                "num_reviews": 78
            },
            {
                "review/text": "I purchased the book to help me out with the recurring task of quickly understanding the nature of unfamiliar large software projects. Kudos to Mr. Spinellis for tackling this subject, which is a large part of the everyday work of programming.Unfortunately, I feel that this book was of very limited use to me as an experienced programmer, and suffers from a rather basic flaw (as a topic). The problem is that the art of code reading is really the intersection of a deep and/or broad understanding of programming, in conjunction with a deep and/or broad understanding of the tools and practices employed. One could well assert that this book is about *debugging* unfamiliar codebases as much as it is about *reading* them, since code comprehension is a component of code debugging. This is a rather apt analogy, since many have attempted to describe the black art of debugging just as Mr. Spinellis has attempted with reading, and with no definitive \"must-have\" coverage to date.The result is that I felt the book rushed through important programming concepts that were either extremely basic (global variables, while loops, conditionals, blocks), or language-specific (C typedef, arrays, function pointers), or too deep for the book to address adequately (trees, stacks, queues, hashes, graphs). With regard to the latter, I found it odd to be reading a lot of text about basic data structures, when it seemed to me that I should be assumed to already have this knowledge if I wanted to read code that used it. And if I did NOT know about basic data structures, I should be reading a book about data structures rather than a book about code reading. Software patterns are also presented (though not by the name, I think). If I was to encounter a codebase that employed some programming concept I didn't understand fully (for example, red-black trees), then I would first go to a book on data structures -- not a book on code reading.Following the sections on what I would consider mandatory prerequisite understanding are some brief chapters software engineering concepts (version control, build systems, project organization, packaging, system structures), which might be useful to a reader who had never worked on a large-scale project before.After all of the coverage of what I would consider prerequisite knowledge, the penultimate chapter finally gets to the topic of tools and techniques for actually reading code. This chapter is in fact what I had hoped Mr. Spinellis would devote the book to. Unfortunately, most of the tools and techniques presented are very basic and quickly encountered by any programmer: regular expressions, the fact that many editors include browsing support, the grep utility, differencing tools, the idea that you could write your own tools, using the compiler to emit warnings and preprocessed code, that beautifiers exist, profiling and annotating printouts. And that's it, in about forty pages, followed by a chapter devoted to an example session.On the whole, I think this book comes up short. If you have a few years of programming experience under your belt, then you've already encountered the basic tools and techniques presented. If someone resorted to this book to learn about a basic programming construct, then they could read my code, but I'd be nervous about letting them modify it, until they read more focused texts.I'm rating this book at three stars because there are some good pieces here and the effort was laudable. In the end, though, I really don't think that anybody needs this book on their shelf.",
                "review/helpfulness": "61/66",
                "num_reviews": 66
            },
            {
                "review/text": "This is the most interesting technical read I have had since the release of Dave Thomas and Andrew Hunt's &quot;Pragmatic Programmer&quot;. Which isn't suprising, given that Dave appears to have been involved with this book as well.The conveys book experience as opposed to raw information. He gives pragmatic advice that will benefit both junior and senior engineers in their day-to-day code and project development.I've become bored with the usually 'foo in three weeks' style books. If you are in the same position and you are interested in books about proven techniques and the pragmatic approach, this book is for you.The first few chapters had me questioning my purchase but the closing chapters removed any doubt that I had spent my money well. There were helpful hints that will save me minutes and hours throughout the work-week which means that I will be working smarter rather than harder.It was only through random chance that I saw this book in the Palo Alto Borders. Great books like these need solid marketing. That being said, I applaud Addison-Wesley in their investment in a book like this which is a little outside of the norm, but is an incredibly valuable work for the software engineering community.",
                "review/helpfulness": "13/17",
                "num_reviews": 17
            },
            {
                "review/text": "A valuable resource for best practices, do's and don'ts, what works and why, what you should do in various situations of project, code, and architecture evaluation, and everything in between. In one phrase, this book depicts Software Engineering's best practices for the real world. No heavy-duty processes to follow, no reading of Software Engineering text books that are over a 1000+ pages. More importantly, everything in this book is REAL. References are given to open source projects where the author took the examples from, and the CD-Rom includes the complete code examples given in the text.The author starts off by giving a background on the most popular programming languages used in the open-source community such as C/C++ and Java. Some scripting languages such as a PHP and Perl are also covered, but the main focus of the book is on C and C++. Data types, data structures and control flow are covered respectively and various best practiced of \"what to-do\" is given for each topic. These topics are somewhat basic, and if you are an advanced programmer, you can read thru these chapters in an hour or so. Even though these chapters are basic, they contain valuable to-do's and best practices that everyone of us will surly benefit from. They style of the book and its structure is nothing like I have seen before and it takes a couple of chapter to get used to it.Chapter 4 is one of my favorite chapters in this book. It talks about C Data Structures. Towards the end of the chapter, the author talks about Graphs and Trees. These two rather complex topics (books have been written on these two topics) are covered so well that with about 20 pages, the reader can get a very good understanding of the topics at hand. Concrete examples from various open-source projects are used again to get the point across, and the source code that is on the CD-Rom is reusable with little effort.The fun begins with chapter 5, Advanced Control Flow. Recursion, exception handling, parallel programming and non-local jumps are the main topics covered in this section. Again, the sample codes really help the reader to understand the topic better, and they also can be refereed to in your next project - something I found very beneficial. Another interesting thing about this chapter is the part that compares the different thread implementation in various languages and platforms - Java, Win32 and POSIX. Example from each implementation is given to show the reader the difference in practices and to get the point across more clearly.If you have ever been bored to death by reading books on Software Engineering and Software Processes and just wanted to be able to have a very light and proven process to help you out with your next project, then Chapter 6 - Tackling Large Projects, is for you. The author starts the chapter by going over some of the design and implementation techniques used widely in large projects such as:The need for a software processComplex ArchitectureThe need to support multiple platformsThe use of OO techniquesOperator overloading techniques when appropriateThe need for Libraries, Components and ProcessesThe need for custom languages and toolsThe use of pre-processing for portability and other reasonsSome or all of these methods are needed in large software projects, and author goes into detail in chapter 6 to cover how these tasks can be accomplished efficiently and proactively throughout the project life cycle. The author starts by going over Project Organization such as directory structure and source tree organization to the build process to revision control for future releases and end the chapter with a topic on testing of software applications.The next two chapters, Coding Standards and Documentation are simply priceless. In about 40 or so pages, the author is able to cram over twenty years of best practices in coding standards and documentation techniques. I have never read a book that covered these two topics so well. If you are a project lead, you can simply take these two chapters and use them in your next project because you will not find anything better elsewhere.The biggest and the most imperative chapter in this book is Chapter 9, Architecture. Various architectural patterns are covered. Each pattern includes a list of projects in the open-source community where it was applied and was proven successful. The author then goes into various Control Models that are used in the industry such as:Event Driven SystemsSystem ManagerState TransitionAnd examples of each of these Control Models along with code samples are given. Various packaging methods and schemes such as namespaces, modules, objects, generic programming, Abstract Data Types and libraries are also depicted in this chapter. Chapter 9 is the longest chapter in this book, but also the most informative one.D. Spinellis did a great job putting this book together. This book is packed with examples, best practices and information that are useful to developers, project leads and managers. Now you can have all the experience of the open-source community, the people that developed Linux, Apache and other popular software applications, at the tip of your finger.",
                "review/helpfulness": "12/15",
                "num_reviews": 15
            },
            {
                "review/text": "Those wishing to understand the various styles of programming and meta-programming that have become common in open source code, as well as those who seek to broaden (if not deepen) their understanding of software engineering, would be smart to pick this up. Not only will this book help you to understand the innards of your favorite or least favorite software, but it provides insight into why the creators made the choices they did. It's not going to teach you about computer science as well as a good textbook will, but it will give you an understanding of and appreciation for what programmers balance in their minds as they shape their complex creations. Think of it as The Story and its Writer (ISBN 0312397291) applied to software.",
                "review/helpfulness": "12/14",
                "num_reviews": 14
            },
            {
                "review/text": "I run a small programming contest over the Internet (Ruby Quiz), so the author of Code Reading: The Open Source Perspective and I share a passion. That's exactly what Code Reading is all about. If you often read the code of others, because you enjoy it or because you are required too, this book contains a lot of tips you probably don't want to miss.Code Reading is collection of hints and tips for anyone examining the code of other programmers. It covers common code idioms, strategies for understanding large software projects, design patterns of common system architectures, how to approach documentation and even style guidelines, useful tools for divining the inner meaning of code, and more. The book presents tactics for the code reader with solid prose and plenty of examples. There's also a nice appendix summing up the author's message point by point.I need to tell you a lot more about those examples I mentioned. The number one complaint about programming books is their often trivial examples that lack depth and would never be encountered in the real world. That complaint will never be leveled at this book by anyone. The author chose to showcase well-known open source code for all the examples in his book. A small sampling of the projects used include the hsqldb Java database, the Apache and Tomcat Web servers, the Perl programming language, and the NetBSD Unix distribution. You heard that right, he pulls examples out of an operating system. It can't get much more real-world than that.The techniques of the book are all encompassing, as far as languages go. However, the majority of the book's examples are in C. C is the most common language used in open source software (according to the book) and it's a good common ground for many of us programmers, so the choice fits. The first three chapters dig into common C coding constructs and data structures. That was nice for guys like me that haven't played with C in a while and just need a little refresher course. However, if you don't have at least some grasp of C going in, this book would probably prove challenging to follow.I'm going to give it to you straight: Code Reading isn't easy. If your looking for a bathroom reader you can coast through, this isn't it. The examples are real and the ideas behind them can get complicated. Each subsection of the book ends with some suggested exercises you can try out, to help the book's wisdom sink in. Many of these are non-trivial and require some effort on the part of the reader. However, they are very rewarding to those willing to apply themselves and you can almost feel yourself getting smarter as you work through them. You will get out of this volume what you put into it, in other words.The book comes with a CD of open source projects. It claims there are seven million lines of data and code and I believe it. The CD includes the projects I mentioned above and more. This is where the book's examples come from and it's a terrific resource for practicing the suggested exercises. This was a very nice touch.The book does try to focus on good code for reading, but it's realistic enough to know that you can't always get that. The author even shows some examples where his expectations worked against him, and talks you through his own process of getting to the truth. An extended example in the final chapter of the book showcases this well. The author pulls an algorithm from an operating system, to embed it in a database written in a different language. This is a real-world task and you get to watch him run into some real-world problems which he must troubleshoot. The rest of the text is even thoughtful enough to point out when you should become suspicious of the code you're examining. I appreciated the focus on what we actually see in the wild, verses what we would like to see.The book's layout is generally fine, but I do have one complaint. Some code examples are inline with the text while others are pulled out into figures. In a couple of places, the figures can become quite small. Also, because figures appear in the normal flow of content, you occasionally see an inline code example split by an unrelated code figure. These issues were not frequent, but they where annoying when encountered.If you're a programmer, odds are you have to read code written by other programmers fairly often. Some of us even do it for fun. Regardless of the whys, Code Reading can make you better at it. I believe that makes me a better programmer and thus is well worth the effort.",
                "review/helpfulness": "8/12",
                "num_reviews": 12
            },
            {
                "review/text": "This book is exactly what I was looking for to lead a seminar in bioinformatics at UNC Chapel Hill that brings together bio-chem-phys students with computer science students to try to raise the level of programming sophistication of the former, and raise the level of biochem/biophys sophistication of the latter. It collects examples of why and how to read code, pointing out lessons about the idioms and pitfalls that can help you write, maintain, or evolve code under your control. Full of good ideas, drawn from a lot of experience, and written with humor.The only problem is that inexperienced programmers, who would benefit most from this book, are unlikely to pick up a book on how to read C programs unless someone tells them to. Experts will find that they have already learned most of these things from their experience, although they may still enjoy this book for confirming what they know. But I think that experts will also enjoy being able to loan this book to inexperienced programmers to transmit the wisdom distilled from experience.",
                "review/helpfulness": "9/10",
                "num_reviews": 10
            },
            {
                "review/text": "I agree with the two previous reviewers (Paul and Hollasch). On the positive side, the author's obviously a serious scholar. His knowledge is broad and on some subjects deep as well. The bibliography is extensive and offers good leads for further reading. However, he attempted to do too much in a single volume. The book title is \"Code Reading,\" but the author covers everything from architecture to revision control to configuration management to documentation, with none detailed enough to be useful. Most code examples covered are in C, but he also sprinkled the book with Java, Perl, and even makefile codes. Take that makefile code as an example, if you are not familiar with makefile, you are bound to be lost in his detailed explanation of the code. On the other hand, if you already know makefile and regularly write or modify one, the explanation is isolated and gratuitous, because if necessary you would rather consult a reference book devoted to that subject. Another drawback is that the author spent too many pages stating the plain obvious, effectively drawning the few unique good points of his own. I also noticed that the author presented outdated or not-so-modern materials. For example, he mixes C with C++ and makes incorrect claims no longer applying to both. (It appears to me that the author had no idea about post-98, modern C++.) Another example is Hungarian notations, which has been discounted by Microsoft, with the advent of C# and their fancy new visual IDE tools.",
                "review/helpfulness": "5/7",
                "num_reviews": 7
            },
            {
                "review/text": "While I have absolutely no doubt that the contents of this book are extremely valuable to developers, it is difficult for me to believe that seasoned programmers would need to read it. In fact, if they are in need of this knowledge, then I truly question their competence.For example, chapter two is titled \"Basic Programming Elements\" and the subsections are as follows:*) A complete program.*) Functions and global variables.*) while loops, conditions, and blocks.*) switch statements.*) for loops.*) break and continue statements.*) Character and Boolean expressions.*) goto statements.*) Refactoring in the small.*) do loops and integer expressions.*) Control structures revisited.Chapters three and four have the titles \"Advanced C Data Types\" and \"C Data Structures\" respectively. The level of difficulty of chapters two and three are generally what I cover in my introduction to programming in C class that has no prerequisite.Chapter five is entitled \"Advanced Control Flow\" and covers recursion, exceptions, parallelism, and macro substitution. In a move that puzzled me, the author used Java code rather than C++ in demonstrating how to code for and handle exceptions. C/C++ code is used in the explanations of recursion, parallelism and macro substitution.Topics covered in the remainder of the book include: revision control, testing, indentation and code formatting; reading documentation, common open-source documentation formats, architecture reuse, regular expressions and searching with the grep utility; code reading tools and code beautifiers; testing and debugging. While C/C++ is most widely used, the author uses Java on occasion, specifically when it makes the explanations easier.I want to make it absolutely clear that I believe that the knowledge in this book is extremely valuable. However, we must be realistic here. The first three chapters are the contents of an introductory C programming class and most of the rest of the material would be defined by company coding standards. Therefore, any new hire, even if they were a programming novice, would be introduced to them in the first few months. If they went through any reasonably effective training program, then they would also be exposed to most of the material in this book.",
                "review/helpfulness": "6/7",
                "num_reviews": 7
            },
            {
                "review/text": "Why do people approach the same problem in many ways?There is no ONE answer to it. The Code Reading is not an easy subject by any means. I do not know of any other book that even tried to attempt at this subject. So, I picked this one with out even thinking twice.The first reaction when I read the book is &quot;what the he... is this all about&quot; :-). I guess, it is the same reaction I had got many times reading and understanding code written by others.Just as in it takes a while to understand and digest a piece of new code you ever come across, it might take a while to get to understand and digest the concepts behind this book. I had to revisit and reread the concepts and apply it to practical situation to be able to grasp the abstractness of the subject in a concrete manner :-).If you are with me this far, probably this book is for you. Still wondering what the heck is all this about? Here is a simple explanation from myside:If you LOVE to do coding, HAVE to read the code for a living, WANT to learn *any* TECHNIQUES, then this book is for you!!!",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            }
        ]
    },
    {
        "Title": "aspectoriented programming with aspectj",
        "description": "In a November 2001 Java Pro magazine article, noted Java pundit Daniel Savarese states, \"The days of Object-Oriented Programming may be numbered, One day we may all be using Aspect-Oriented Programming .\" While this may be hyperbole, the AOP bring certain needed improvements to the OOP. AspectJ is a Java-based tool that allows developers to apply standard Java syntax to AOP principles, much as C++ allowed C programmers to use C syntax in an object-oriented manner. There are AspectJ add-ons available for Borland's JBuilder, Sun's Forte for Java and for the EMACS text editor. Aspect-Oriented Programming with AspectJ introduces AOP and the AspectJ tool. The book also shows how, by using existing Java programming knowledge, the developer can use AOP in meaningful development work.",
        "authors": "['Ivan Kiselev']",
        "infoLink": "http://books.google.com/books?id=K5NQAAAAMAAJ&dq=Aspect-Oriented+Programming+with+AspectJ&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "I have never rated a book as lowly as I have for this one. It is horrible. Let me count the ways:1. They forgot to edit the bookNot only are there spelling errors and grammatical errors, but numerous code errors, API errors (or ommissions), and code left out of the book! The grammatical errors actually make certain parts of the book impossible to understand. I had to search on the web to find the answers.2. VERY poor organizationIn one chapter he tells you the code you'll need to compile something we won't do until four chapters later. Worse, although he attempts to create an incremental build of your code, the code you can download online only works in the final version. Of course if the book actually had the incremental code that wouldn't matter, but it only has some of it. I spent half my time just trying to figure out what in chapter 4 goes with what in chapters 2, 5 and 7 (for example).3. Missing SQL CodeI had to guess what the tables were like since he forgot to include SQL code in the book AND (!!!) it isn't in the code download online either!4. Poor explanation of everythingAlmost every example he gives in the book has either no explanation, or a useless one. For example, he might tell you that some code \"introduces\" the class to their new parents and that \"introduce\" is the official name for this action. Of course, don't ask him to define the keyword \"introduce\" for you. You have to figure that out for yourself. This whole book reads as though it were written by someone who loves to be smart, loves big names and acronyms that define him as a high level programmer and doesn't want to sound too simple by actually taking the time to explain it to you. As they say, \"those who can't do, teach.\" In other words, those who weren't naturals at it had to struggle to learn so they understand they have to explain it to you - Kiselev does not.Don't buy this book.",
                "review/helpfulness": "24/29",
                "num_reviews": 29
            },
            {
                "review/text": "I liked that book - it manages to squeeze a lot of new information into relatively small volume - though may be at the expense of the ease of understanding by novices.Explanations are concise and relying on reader's intelligence, without &quot;I'm teaching you&quot; condescending approach so common for many &quot;methodology&quot; books.Code examples are useful - if you don't care much to compile them. They rather have to be treated as pseudo-code that illustrates the AOP concepts - and very effectively, I think.I wish more books like this one were published - short, to the point, respecting both my time and my bookshelf space.",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            },
            {
                "review/text": "After reading piles of aspect oriented papers, primers, and so forth, this book was a refreshing change. Clear, to the point and intelligent, this book is a must have for anyone serious about AOP or AspectJ. The book is presented in three main sections: an example application, a guide to AspectJ itself and a host of appendices, including Patterns and an API reference.This is the first book on the subject. Mr. Kiselev is in a difficult possition: the technology is still so new, and the developements in the area over the course of the next few years will be major, most likely rendering much of this work useless. Right now, however, this is the book to get. When the time comes, we can only hope he updates.",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            },
            {
                "review/text": "As the subject is relatively \"new\" for the general public, the documents obtainable from [URL] had been the best tutorial until the arrival of this book.The author has a in-depth understanding on the AspectJ and he was able to present his knowledge clearly in his book. The \"aspect traces\" provided were able to help the readers understand how AspectJ really works. The examples helped me to grasp the difference between the \"call\" and \"execution\" pointcuts.I didn't give this book five-star because the few chapters on the \"AspectNews\" application were not convincing because I don't think it likely that AspectJ will be applicable to a non-trivial Web application for the exact reasons given by the author in the last chapter (ch. 14) of the book.",
                "review/helpfulness": "2/2",
                "num_reviews": 2
            }
        ]
    },
    {
        "Title": "practical introduction to data structures and algorithm analysis",
        "description": "This practical text contains fairly \"traditional\" coverage of data structures with a clear and complete use of algorithm analysis, and some emphasis on file processing techniques as relevant to modern programmers. It fully integrates OO programming with these topics, as part of the detailed presentation of OO programming itself.Chapter topics include lists, stacks, and queues; binary and general trees; graphs; file processing and external sorting; searching; indexing; and limits to computation.For programmers who need a good reference on data structures.",
        "authors": "['Clifford A. Shaffer']",
        "infoLink": "http://books.google.com/books?id=uPwkAQAAIAAJ&dq=Practical+Introduction+to+Data+Structures+and+Algorithm+Analysis.&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "I used this textbook to teach Data Structures and Algorithms at the sophomore-junior level to a class of 100 students. My primary focus is to teach the design and use of DS&amp;A with a secondary focus on implementation in a specific language (Java in this case). From this point of view: Part I is excellent. Part II is above average. The discussion of trees is average with an implicitly narrow view of applications. Part III on sorting and searching is average with the exception of the horrible discussion of benchmarking in 8.8. The data are unqualified and misleading (compiled and interpreted run-times are compared as equals!). The discussion of hashing and B-Trees is poorly organized and narrow. Parts III and IV are oriented towards Java implementation. As such, there is no discussion of the limitations of actually using recursion in an implementation nor the efficient use of object-oriented structures in cache-based architectures. For a better discussion of DS&amp;A, many of my less experienced students found relief in Robert Lafore's book (ISBN 1571690956) and the more advanced students consulted Weiss's text (ISBN 0201357542). For the following term I will try Cormen, Leiserson, and Rivest's classic Introduction to Algorithms (ISBN 0070131430) which uses pseudo-code and Lafore's book as a required supplement.",
                "review/helpfulness": "12/12",
                "num_reviews": 12
            },
            {
                "review/text": "I'm a M.S. student at Virginia Tech and had to use this book for a class. A lot of the java code in this book should be chucked, and this is coming from a sun certified java programmer. Unconventional identifiers, supposedly predefined methods that don't exist in java API, little attempt to clarify the code specially in the graphs chapter (7). Appears to be poorly translated C++ code just thrown into the book. I was so frustrated re-reading sections of a code 10-20 times just to understand what he was on about. This calibre of programming I would expect from a confused college kid whos stayed up all night working on a project, not from a college professor. During his explanations in class our professor (not Shaffer) has pointed out several conceptual mistakes to date. Conclusion: Not college textbook material.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "Overall, this book is simply awkward. The code is difficult to read and the text is hard to follow. Also, there are few, if any, practical examples. If this book wasn't required for the class that I'm taking, I would definately pass on it.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "Lots of examples and thorough coverage give this book a shot at being a valuabe book. However, Shaffer's coding style is difficult to read and often bogged down in overly object oriented complexity. Furthermore, unintuitive explanations of concepts make the non-coded aspects of the book frustrating to read. Taking the books price (currently $63.00 new) into consideration, I'd pass this one up.",
                "review/helpfulness": "5/6",
                "num_reviews": 6
            },
            {
                "review/text": "...but this was a mandatory book for my university's two-course Data Structures & Algorithms sequence that all computer scientists and computer engineers must take.Coming in with a good deal of programming experience, I find that this book is not as clear or as complete as it could be. The sample code snippets throughout tend to be awkwardly implmented with obscure variable names and obtuse datatyping, and more often than not represent 'a' way of accomplishing a task rather than 'the best' way. Finding better ways of doing things is normally left for exercises at the end of the chapter; the answers are not included with the book.Also, many significant details or comments are skimmed over or are ommitted from the text. Many important (and complex) observations are left as exercises - but again, the answers are not included, so there is no way of validating your answers.Further, this book is targeted at the C++ language. It is obscene to discuss data structures and algorithms without mentioning the free, prepackaged, and optimized code of the C++ Standard Template Library. Indeed, this book and the code it includes would have benefitted from the ingenious architecture and software engineering behind the STL.I really hope the campus bookstore will buy this one back when I'm done with it.",
                "review/helpfulness": "4/5",
                "num_reviews": 5
            },
            {
                "review/text": "I am a Computer Science student at Virginia Tech and Cliff Shaffer taught my Data Structures class. This book was used in the class, and many of my fellow students would agree, this book is awkward in every sense of the word. Not only is the material poorly written and confusing, the code examples didnt help much either. I found myself constantly reading and re-reading sections that were needed for programming assignments and going huh? If you have a strong desire to learn data structures, keep looking for your data structures book, this one isnt it...",
                "review/helpfulness": "4/4",
                "num_reviews": 4
            },
            {
                "review/text": "This book is definitely not for a student to read. A lot of sentences are very difficult to understand. I have to read a few times to try to understand. Also this book lack of examples. I don't understand why we have to choose to use this book as a textbook.",
                "review/helpfulness": "3/4",
                "num_reviews": 4
            },
            {
                "review/text": "I would have to say that i'm very much angered by the poor quality of this &quot;textbook&quot;, if it can be called a textbook. A textbook, by definition, should try to explain everything in detail as much as possible and convey the concepts in a clear and well-illustrated manner. On the contrary, this book is full of partial details in long-winded sentences, which makes a already hard topic even more difficult to follow. As a textbook, it is counter-productive. Maybe the author dont want to bother, but the lack of detail and jumping of thought is striking in this book, not to mention the incomplete, half-baked C-like Java code that does not even compile. It is a shame that it is used as a textbook anywhere, it is even a bigger shame that some school selects it as textbook for the reason other than academic.",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            },
            {
                "review/text": "Frankly, I was extremely disappointed with this book. I originally bought it for a Data Structures class and soon found that it was never of any use. The book is extremely hard to follow and, at times, fails to include enough information. Such as Big-O notation. I count a total of 5 pages that show no useful examples but constantly talk about Big-Oh (notice the &quot;h&quot;) while providing no solutions to finding the bounds.",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            },
            {
                "review/text": "I have been using this book for a college course and have found other texts that are much more clear. I am disappointed with the authors examples of Java code due partly because of his breaking conventions in naming and compact style. The author repeatedly uses unconventional names for his classes which results in hard to follow implementations. The author also uses his own custom classes (which is not necessary for study) in his examples. The author has decent explanations of various notations such as Big-O, Big-Omega, and Bit-Theta. However, I would not recommend this book for any introductory course in data structures and algorithm analysis.",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "aspectj in action practical aspectoriented programming",
        "description": "Explains the concepts of aspect-oriented programming and the basics of the AspectJ language.",
        "authors": "['Ramnivas Laddad']",
        "infoLink": "http://books.google.com/books?id=2efVVV8G6oMC&dq=Aspectj+in+Action:+Practical+Aspect-Oriented+Programming&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "Ramnivas Laddad wrote a comprehensive book on AOP with the focus on AspectJ. He deals with AOP and AspectJ basics, explains the (sometimes fine) differences in advice declarations, and cleans up the myths and prejudices on AOP.Going further Ramnivas uses real-life examples to show step by step how to use Aspects in your daily work. He explains how to transform a pure Java based solution to a cleaner, more structured AspectJ solution. The reader can see that the AspectJ solution is more elegant and can always understand how Ramnivas came to his solutions. Ramnivas explains this for cruicial topics most developers have to face, for example logging or thread safety.Special bonus is the chapter on aspect design patterns. Ramnivas shows four design patterns, that don't exist in the non-AOP world. They are quite useful in AOP, though, and AFAIK there is no other source for this important information.&quot;AspectJ in action&quot; is a book for beginners as well as for advanced AspectJ programmers. It is well written and easy to understand. The real-world examples allow you to transfer the solutions on a 1:1 basis to your project and thus try in real life how aspects work for you.",
                "review/helpfulness": "19/20",
                "num_reviews": 20
            },
            {
                "review/text": "I have got this book at local Austin Java User Group meeting. First impression: different cover. Most of Manning books are either greenish or almost black-and-white. This one is yellow.Part 1 provides really good introduction into AOP. This is the first book I have read on AOP; all stuff I have seen before was online or magazine articles. One interesting fact is that this book took a while to consume, compared to the usual two-week cycle I have for technical books. I guess the reason is that the book has more substance than most of the techincal books and Mannigs does not try to pad their books with API references and other stuff that can be easily found online. After the chapter goes through AOP concepts, it explains AspectJ in application to those concepts. Basic syntax as well as some advanced techniques are explained.Part 2 has examples of basic applications of AspectJ. Of course it starts with the mandatory logging implemented using AOP. Not a very good example in general, since logging is not really a cross-cutting concern, but works for illustration purposes. Other two application areas discussed in this part are implementation policy enforcement and optimization (pooling and caching examples). Policy enorcement part is really interesting, especially if you are into call patterns.In general, every part follows the same pattern: first the author discusses the conventional approach, then explains challenges of the conventional solution, provides AspectJ-based solution, and gives one or two examples. Very clean language, easy to follow.Part 3 discusses advanced applications of AspectJ. First it delves into design patterns and idioms of AOP; it's not by any means AspectJ-specific, so would be useful for any AOP implementation. Examples of patterns are providing thread-safe implementations using AspectJ, implementing security (very interesting discussion on JAAS), transaction management, and implementing business rules using AspectJ. The part ends with AspectJ usage in different development phases.Two appendices: description of AspectJ compiler and Ant integration - only 15 pages for both. Useful as a reference.Overall impression: an excellent book. Definitely worth reading, even if you are not into AOP yet.",
                "review/helpfulness": "19/19",
                "num_reviews": 19
            },
            {
                "review/text": "I met the author of this book this weekend, and saw him give a presentation on this material. Finally, a book that shows real uses for AOP.I have been watching AspectJ since I first saw it about a year ago. My first impression was that it was 'cool', but was worried about giving developers more rope with which to hang themselves. Yes, it was cool, but the most practical examples you would see in demos were thing like 'logging'. I was worried that it would just lead more more ways for junior engineers to 'convolute the code', without bringing much benefit for that risk.The material in this book, ALONG WITH the support the author had from the Eclipse IDE changed my mind. Finally, there were some real examples involving transaction support, JAAS, exception handling, and more. Furthermore, he addressed these topics in the real-world sense of refactoring existing code to prove his points.If you aren't using an IDE that gives you some support, then I still have my concerns about 'convoluting' your code; but I am more convinced than ever that AOP concepts are worth putting into my mental toolkit. I have no doubt that the way aspects 'inject' behavior into code will reduce our development time, and make our code behave more consistently (no errors because of inconsistencies in the way common things are handled). If you can add one more ball to the things you 'mentally juggle' while developing, add AOP concepts. This book will help.",
                "review/helpfulness": "10/10",
                "num_reviews": 10
            },
            {
                "review/text": "I am a beginer in AOP and before I picked this book, terms like point cuts, advice sounded greek and latin to me. However after reading through the book, I now know exactly what AOP is and how to program using AspectJ.AOP seems to have come of age and this book is excellent resource to come upto speed.The book is divided into three parts.The first prat introduces AOP, why AOP and about AspectJ in a very easy to understand manner. Best intro I have ever read.Then it introduces the syntax of AspectJSecond part introduces more advanced techniques and makes you really good at AspectJ.Third part of the book is a real gem. Here you find, excellent and practicval uses of AOP in every day scenarios.I am currently reading this part now and I feel confident talking to my boss to start using AOP at work.A must read for anyone wanting to study AOP",
                "review/helpfulness": "7/7",
                "num_reviews": 7
            },
            {
                "review/text": "AspectJ In Action is a great book to use as an introduction to Aspect-oriented Programming. However, AOP is not for developers to whom Java and OO are still new. Without a comfortable understanding of classes, polymorphism, and encapsulation AOP will only further confuse things.With that said, AspectJ In Action is a wonderful book filled with plenty of examples and explanations about the well-lit areas of AOP as well as many of the dark corners. I enjoyed reading this book because it starts out with the fundamentals and works its way to more and more complex uses of AOP without getting bogged down in language tangents. Also, the direct application of AOP in real Java design areas is very helpful in getting a better feel for when and how AOP can be applied.I am looking forward to Ramnivas Laddad's next book!",
                "review/helpfulness": "5/5",
                "num_reviews": 5
            },
            {
                "review/text": "I loved this book, first of all the introduction is the most interesting presentation of AOP that I ever read.The other chapters are very good too since based on use-cases very easy to reproduce on projects...A book to have is you want to learn abour AOP (even if not interested by AspectJ per se...)",
                "review/helpfulness": "3/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "practical statecharts in cc quantum programming for embedded systems with cdrom",
        "description": "'Downright revolutionary... the title is a major understatement... 'Quantum Programming' may ultimately change the way embedded software is designed.' -- Michael Barr, Editor-in-Chief, Embedded Systems Programming magazine (Click here",
        "authors": "['Miro Samek']",
        "infoLink": "http://books.google.com/books?id=eUhZDwAAQBAJ&dq=Practical+Statecharts+in+C/C++:+Quantum+Programming+for+Embedded+Systems+with+CDROM&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "A couple of months ago I would have fully agreed with most of the reviewers: yes, statecharts is an important topic, and Samek covers it well. Indeed he does: The book is chock-full of (working!) code and will give you a head-start at tackling difficult behavioral control problems. I do not develop real-time software, but thinking of _every_ software as if it were real-time can increase quality. I feel I gained a lot of insight, and it made me rethink some architecture issues.You can brush over the quantum-babble, mainly because it's irrelevant and an already overstreched analogy-for-everything. With regards to Statecharts, no harm is done that Samek is evangelizing a little bit too forcefully.So why 3 stars only? After working with the concepts and coding a number of statemachines the Samek-way, I started to notice that Samek's approach does not quite deliver as promised:* Be prepared to be disconnected from the community: Samek's statecharts part in a lot of aspects from the UML 2.0 statecharts (although there is a website w/ quite a lot of activity). Looking at UML-compliant statecharts from fellow developers you will realize that you cannot transcribe them easily using Samek's framework. Main reason: UML has functionality (= non-statemachine code) in transition actions and event guards, Samek in state event handlers.* Samek's statemachines are \"run-to-completion\", which results excessive self-posting of events and queuing. Although the code is not spaghetti, the execution is - and debugging is _very_ difficult.* After a while, it is very difficult to infer the statechart semantics from the code. I certainly want to believe Samek that there is no real value in separating semantics (= statechart description) from functionality (= code which uses the statemachine), but this turned out to be a maintainance nightmare.* Samek's statemachines do not offer orthogonal states, but for bigger projects you will need orthogonality to model concurrent aspects of a system. The lack of orthogonality is salvaged by the publish/subscribe framework also included in the book: You just use a number of statemachines and connect them via a message bus. This might work in the real-time space but it's obviously not something you will be able to include in your software. As a consequence, it is difficult to use statemachines in a \"tactical\" fashion.David Harel (the inventor of statecharts, see his paper from '87, e.g. on citeseer) designed statecharts as a visual language to enable thinking (alone and in the team) about the behaviour of systems. Samek disagrees: coding and thinking go hand in hand. This might seem to be very \"agile\" but there are pitfalls. Actually he seems to be as strict in his assertions than Harel is - not agile at all.There are approaches which are more balanced in that they mimic statechart semantics \"better\" (= more UML-compliant) than his. Take a look at SCXML (XML-driven, Java-interpreted) or at CHSM (C++/Java code generation). Also take a look at the roundtrip modelling tools which (most likely) ship w/ your preferred development environment.Samek is very up-beat and a strong believer in what he says. I bought into his vision and hoped for a productivity / morale boost comparable to using unit tests (like JUnit). It never really turned out that way, and statemachine coding &agrave; la Samek remained a trial-and-error business until I decided to use a different approach.It's an important, very original book, and an interesting read. My advice: Give it a try, but don't get carried away.",
                "review/helpfulness": "46/52",
                "num_reviews": 52
            },
            {
                "review/text": "Since I am not from the embedded system world, I was a bit apprehensive about approaching this book. While I can see that author Miro Samek has a directed target for his audience, I strongly feel that this book is a \"must read\" for technical developers in all areas who want to improve their program design abilities or developers who want to understand the philosophy, use, and implementation of statecharts intimately.As the title indicates, this book brings the topic of statecharts from the realm of expensive design tools to the PRACTICAL realm, illustrating its points with full examples and extensive commentary.Essentially Samek postulates that the slow adoption by developers of best practices by statechart design is due to lack of understanding of the fundamental nature of statecharts and how it is perceived as requiring expensive tools to use well. Samek insightfully discusses how statecharts as a best practice embody \"behavioral inheritance\" as a fundamental design concept that stands as a peer alongside the conventional pillars of object-oriented programming, namely inheritance, encapsulation, and polymorphism.The book is very technical and written in an academic style, with ample references to original sources as well as detailed code reviews and many reader exercises. I would caution anyone from approaching this book as a quick or light read. For me, it took a seriousness and good understanding of C and C++ to follow Samek's examples and achieve the \"a-ha\", which was always worth it in the end.The two basic parts of the text are (1) an explanation of statecharts and their methodological implications, and (2) a description of how to apply statecharts as a data structure in real applications, namely embedded as control strategies for \"active objects.\" In several places in the text, Samek makes an analogy between statechart (and active object) semantics and quantum mechanics. This parallel was an interesting philosophical argument, but didn't add much for me in terms of accepting his \"quantum framework\" as a best practice -- I was sold by his methodological arguments he had presented already.Speaking from experience in writing a book about using statecharts to build simulations, I can say Samek is a visionary who extended my perception of statecharts several steps. I know I will be quoting from it and referring to it in my work to come. This book has earned a prominent place on my bookshelf, and I would heartily recommend it to any other developer who wants to create correct, verifiable, scaleable, and solid designs (which should be ALL developers!).",
                "review/helpfulness": "25/26",
                "num_reviews": 26
            },
            {
                "review/text": "This book has done a great job in consolidating many key concepts and techniques in embedded software design. Though state machines and event-driven design are not new, the author proposed a truly reusable and integrated framework which is very well designed and particularly suitable for resource constrained embedded systems.Author's implementation of state machines is innovative and remarkable. It supports state nesting, automatic execution of entry/exit actions and default event handling by superstates. This allows you to implement UML statecharts in C++/C conveniently.In general this book is very clearly written and comprehensive. Its reference list is also valuable, pointing to some classics in OOD and good articles in Embedded Systems Programing. This book will definitely become a classic in embedded software itself.On the downside, I find the repeated analogy of the software model to quantum physics overwhelming. Besides the author chose to show you examples and implications before showing you the details and internal. This kind of abstraction may pose some question marks in your mind when you read the first few chapters. But do read on and you will appreciate the great ideas.",
                "review/helpfulness": "14/14",
                "num_reviews": 14
            },
            {
                "review/text": "I think the title is a little misleading.It is more a introduction to state machines and implementing them on embedded systems. It fact it is more about developing on embedded systems!Having said that it does it very, very well. I would even reccomend it to non-embedded developers,particularly the sections on multi-threading issues and Active objects.I'm not sure who the audience is though. A lot of embedded developers are unfamiliar with C++, UML while non-embedded developers may not even think that state machines could be useful to them.I appreciate the quantum physics analogies, but I don't think they needed so much space.The section on implementing O-O in C is good, but once again,is it relevant to a book on state-machines and active objects.The framework looks good, butI would tweak the C++ version to get rid of all those macro's and function pointers! Particularly if you wanted to port it to java.Excellent book but change the title!",
                "review/helpfulness": "12/12",
                "num_reviews": 12
            },
            {
                "review/text": "I want to congratulate Miro Samek for his book.The book is well structured. The UML Statecharts are well introduced. The Actives Objects approach and the related Framework are very attractive. With the Framework (QF) for embedded real-time systems included, you are really able to use it for your application. You can then focus on your application objects and no more on the &quot;glue&quot; around them. You have a common strategy for all your applications.The best book on UML for embedded system from a long time.",
                "review/helpfulness": "11/11",
                "num_reviews": 11
            },
            {
                "review/text": "It's not an easy-to-read book because the topic is complicated.But the technique described in this book which is developed by Samek is very sophisticated - the library code is light weighted, the interface is easy to use, and the logic mapping from the statechart to the implementation is straight forward. This is the conclusion I got after applied this method in the development of a complicated behavior control for a medical device.Many technique books were put together quickly without solid practical value, not this one!",
                "review/helpfulness": "6/9",
                "num_reviews": 9
            },
            {
                "review/text": "Most of the embedded books I've read mainly focus discussion on basic assembly language (such as interrupt subroutine) and simple hardware interfacing (for instance, keypad, debouncing). I've been looking for book discuss on larger embedded program. If you have mastered the basic skill on microcontroller, this book will definitely enhance your knowledge on the embedded software architecture .I used to put a lot of flag in my program to indicate the state. This will eventually become confusing as program grow larger. The knowledge on statechart that I learn from this book greatly tidy up my code, even I have only finished reading a few chapters. The concept is well-explained with the aid of chart diagram and codes. Furthermore, this books is platform independent, you can use it on any microcontroller. I highly recommend this book to intermediate and advanced embedded programmer!",
                "review/helpfulness": "7/8",
                "num_reviews": 8
            },
            {
                "review/text": "I noticed the first version of the hierarchical statemachine framework from Samek in ESP magazine August 2000. It seemed interesting and very efficient but on this book Samek has improved the framework a lot. Multitasking is included for example.In addition the book gives good examples and instructions to use the framework in embedded systems software projects.If you think you should re-think your architectural design in your embedded project read the article in ESP magazine ...",
                "review/helpfulness": "7/7",
                "num_reviews": 7
            },
            {
                "review/text": "This book was a definite eye-opener for me with regard to state machines. I recently rewrote a major piece of code to utilize the Quantum Framework (included with the book) and it has worked wonders. My previous code used a more traditional state machine and had quickly evolved into spaghetti code. The hierarchical state machine approach made the new code smaller, more robust, and much easier to maintain and extend.",
                "review/helpfulness": "7/7",
                "num_reviews": 7
            },
            {
                "review/text": "Firstly: I am sorry about my English.I think that this book is really useful and very interesting for each interesting in C++/C. And want write programs with HSM behind as behavior rules of program.For conclusion: Useful and easy reading book.",
                "review/helpfulness": "2/3",
                "num_reviews": 3
            }
        ]
    },
    {
        "Title": "virtual machine design and implementation cc",
        "description": "This is an in-depth look at the construction and underlying theory of a fullyfunctional virtual machine and an entire suite of related development tools.",
        "authors": "['Bill Blunden']",
        "infoLink": "http://books.google.nl/books?id=kfUrpHUiO8kC&dq=Virtual+Machine+Design+and+Implementation+C/C&hl=&source=gbs_api",
        "review": [
            {
                "review/text": "I am more or less dissapointed with this book's contents, largely because I expected a bit more modern treatment of the subject.What greatly dissapointed me was that the author doesn't compare his VM against others, which is quite a pity because there are modern languages interpreted using VMs like Java, Perl, Python and many more. This and some more facts suggest that the author is not in sync with current development in the field.An another surprise for me is that the VM introduced is register oriented. I don't quite understand and agree with the arguments behind this choice, as opposed to stack based VMs. The author explains about computer processors that utilized the stack based architecture in the past that were outperformed by register based CPUs, thus they are not manufactured anymore. Which is a misleading fact, because registers of a VM are located in memory arrays, and suffer from the same efficiency penalties as the stack does.Targeting a register based VM is much more difficult than with stack based VMs, but the author doesn't take attention to this fact. More precisely, he doesn't say a word about generating code for his VM aside from a simple assembler, that is explained at great lengths in a separate chapter, which I find somewhat uninteresting and off the topic, because only a few people really write code for VMs in assembler.The book contains lots of code listings, that the author comments on well. The language used is much more C than C++, which is a pity in my opinion, but hey, the programming tastes differ.What is worth noting, the author doesn't go beyond a naive one-large-switch VM implementation, which is not to blame, but it would be appreciable if the author noted some optimization techniques for VMs like direct-threading, inline-threading and just-in-time compiling.Bill Blunden is overproductive in some areas, for example he tends to describe on a number of pages techniques like threading, but in the end only to explain that the VM doesn't contain any thread support at all.In the end, I enjoyed some parts of the book, as it contains some notes about computer science history. But I can't avoid the feeling that the author got stuck in '80s and is not aware of the recent development.I do not say that the book is bad, it just didn't fit me.",
                "review/helpfulness": "26/27",
                "num_reviews": 27
            },
            {
                "review/text": "This book describes, in a simple series of steps, how to construct a production-quality runtime system. This includes powerful features like TCP/IP networking, interfacing to native code, and synchronization primitives. Everything that you would expect from a commercial runtime system is presented in explicit detail.This includes the source code and documentation for a full set of development tools (like a bytecode assembler, symbolic debugger, and binary analyzer).There is also an extended discussion of how the book's virtual machine can be ported to other platforms. To this end, the author offers a critical path analysis of the development process so that the reader can build their own virtual machine. This is followed by a critical path analysis of the procedures necessary to build an entire operating system!The author obviously knows what he is doing and is coming from a heavy 80x86 background. There are several points in the book where the author discusses actual hardware implementations of system I/O, paging, and interrupts. You can tell that Barry Brey was the technical editor.What I liked best was the authors explanation of how object-oriented concepts are implemented in bytecode. Probably the most concise discussion of exceptions, encapsulation, and inheritance that I have ever seen. Cool.",
                "review/helpfulness": "15/23",
                "num_reviews": 23
            },
            {
                "review/text": "Though there were several topics that this book covered that I liked, the author (Bill Blunden) seems very confused about many other things. It was obvious that Mr. Blunden's formal education was not in computer science. He would go through lots of trouble to \"optimize\" protions of code (instruction handlers), making them unreadable, that any decent optimizing compiler could have taken care of. Then he would go and do something silly like passing data (argc and return values) between the VM and native libraries in XML. The 2 cases for using a native library call from VM code are for added speed or to make a system call. The conversion to/from XML adds bunches of overhead where it is needed least.The author also says nasty things about his experience porting the HEC VM to Linux that don't make any sence (though the publisher seemed to really push the fact that there was a Linux port). He states that the only way to use a shared object library from a Linux program is to include it at compile/link time. This is silly, since under Linux, all shared object libraries are loaded at run time, even those that are specified to the linker (by way of ld-linux.so) (see dlopen(3) \"from Solaris\" and uselib(2)). Besides, Java does it, so I can't be imposible. The author says nasty things about the documentation of Linux sys-calls and libraries with his distribution in comparison to MSDN. What he doesn't notice is that he has paid for WindowsXP, Visual C++, and MSDN (3 separate products or 2 if MSDN comes with VC++). Under Linux, this was not the case, as all he paid for was a distribution and got the developer's tools and the man pages (specifically sections 2 and 3) as well as the standard OS (as compared with WinXP).His Linux port of HEC was half hearted, in that he seemed to have bought a distribution (new to him) with the intent to port, while he was used to programming with VC++ for Windows. He claims early in the book to have been an old Unix guy, but I find that hard to believe. I am a Linux programmer. I rarly write anything for any MS OS that is not trivial. I know that if I were asked to, I would have a bunch of learning to do.Another thing about this book that was annoying was the constant process of going over a topic, seemingly as an included feature (like multi-threading) in the VM, only for him to decide that it would not be added. Because of this, his VM seems weaker to me.The author also was very anal about not running in Virtual Memory. WHY?? It should be a user choice. He omited the restriction from the Linux port because he couldn't figure out an easy way to find the free memory (parsing /proc/meminfo was too hard, while parsing XML in the dynamic loaded library system was not, no mention of free(1)).Further, the files on the CD (under linux/ ) are not set to reasonable permissions and he uses shell scripts where Makefiles would normally be used.Many other things that I didn't like, but I'm tired of typing.Things that I did like were his coverage of the implementation dynamic binding of functions/methods in object oriented programming and his coverage of 2 versions of exception handling.",
                "review/helpfulness": "20/21",
                "num_reviews": 21
            },
            {
                "review/text": "It reads like the personal diaries of Bill Blunden as he endeavors to build the HEC virtual machine. The best aspect of this book is that Mr. Blunden has done a decent amount of investigations into the process of building a VM. He describes all of the components of his VM with abundant detail and clear writing. The HEC VM is more of a toy than a commercial VM, but its design is informative. Mr. Blunden also gets credit for included error handling in his code. Too many other books skip error handling &quot;to save space&quot;. This book also happens to be one of the only VM books I've found that is not about the Java VM (which is a stack machine as opposed to a register machine like HEC).Unfortunately there are several problems with the book. The biggest problem is confusion about its target audience. In many places the book appears to be written for totally inexperienced developers while at other times it assumes a decent amount of existing knowledge. For example, the book describes that disk access is slower than RAM access, what a debugger does, provides lots of details and code examples of simple data structures like dynamic arrays, etc. At the same time the book assumes good working knowledge of the C, C++, and Java languages, an understanding of file I/O, and other concepts. How many developers know C/C++ and Java but don't know what a debugger is for?The next problem with the book is the actual code. It has many security problems such as unsafe strcpy and scanf usage, too many unnecessary preprocessor macros (created for unconditional code blocks that are only used once), and strange C style C++ code (classes that are passed their own data members).The final issue is the book's personal diary style. Some people may enjoy this, but I did not. The book is filled with little sections labeled &quot;Rant&quot; where Mr. Blunden goes off on something. In a strange section about the future of computers he comes up with this: &quot;Imagine how a government could use this kind of tool to repress its citizens by instituting behavior modification on a national scale.&quot; And what does this have to do with building a VM? If I wanted a novel I'd buy one (or write one in an Amazon review :)If you are a C/C++ developer and want details about building a VM, this book gets very slow and you will end up skipping 30 to 60 percent. If you are an inexperienced developer, however, the example code may be over your head. In the end, I'd say this book is best suited for new developers (or even non-developers) who want background information about computers and virtual machines, but don't care about using the example code. The book would be a 3 to 3.5 star for someone like that.",
                "review/helpfulness": "19/21",
                "num_reviews": 21
            },
            {
                "review/text": "I was extremely disappointed with this book, especially as it received so many positive reviews here on Amazon.To begin with, this book is billed for intermediate to advanced programmers. This book has little to offer for an \"advanced\" programmer. However, it's not bad for an advanced beginner to intermediate reader. The concepts discussed are simplistic. Only one short chapter is dedicated to the actual virtual machine. Blunden devotes more pages to discussion of basic data structures like symbol tables and hash tables than he does to his virtual machine. His biggest chapter is devoted to implementing a macro assembler for his machine. A discussion I would expect in a book on compiler design, but which I found somewhat unwelcome here.His coverage of virtual machines leaves much to be desired. The two primary topics that interested me, multi-threading and garbage collection, aren't even covered. Blunden describes them as complex topics, and therefore he leaves them out of his virtual machine. Since the reason I read books is for discussion of \"complex\" topics, this feels more like a cop-out than a design decision to me.If you read his code, please don't try to emulate his coding style. He describes data types that he never uses, choosing instead to reimplement concepts every time he uses them. He exports public members of C++ classes, uses descriptive function arguments like \"ptr\", and spends a lot of time talking about optimizing things that don't really require optimization. (Loop unrolling your debugging statements?) He switches to C++ halfway through the book, but fails to take advantage of any of C++'s strengths. I almost get the feeling his editor told him that his book would sell better if he listed C++ in the title.I'm sure Blunden is a smart man, so I'll give him the benefit of the doubt and assume that his assembly language background is peeking through. But if your interest is virtual machines, I suggest one of the many good books on the Java VM. If your interest is compilers, stick with the Dragon book, or check out Allen Holub's book if the Dragon book is too rigorous. If you're looking to learn C or C++, look elsewhere.",
                "review/helpfulness": "19/20",
                "num_reviews": 20
            },
            {
                "review/text": "A vanity book that no decent publisher should print.Material about the stated subject is so outdated to be laughable.Otherwise filled with totally irrelevant, ill-informed, pretentious material. Mostly useless code listings.",
                "review/helpfulness": "14/18",
                "num_reviews": 18
            },
            {
                "review/text": "Wordware and Bill Blunden know how to make a great book. The writing is clear and direct, without becoming dry and boring. The examples are practical, and the coding conventions are easy to understand. Bill puts everything across in a way that doesn't insult programming experts, but that any amateur could understand.This book doesn't just cover virtual machines. It's a great book for anyone who wants to learn more about computer science in general. Bill explains how interrupt vectors work, how debuggers and assemblers work and how to make your own, the ins and outs of memory management and garbage collection, and how processors operate. It's all here.The virtual machine featured in this book (the author's own 'HEC' program) is deftly constructed, and Bill rationalizes every part of the design process. What's good about register based virtual machines as opposed to stack based ones? Once again, he covers it all.And, yes, his virtual machines does everything too. He even goes into working with TCP/IP, graphics, and so on. This isn't a featherweight virtual machine that adds numbers.. this can be used as an enterprise scale runtime engine!Virtual machines are rather important these days. The whole of Java operates on a stack based virtual machine. And the entire underbelly of Perl 6 (currently in development) is a register based virtual machine called Parrot. If you want to be at the forefront of modern machine theory and technology, you need to be up to date with virtual machines. Even .NET operates as a virtual machine. If you're a Comp Sci graduate, or even just a freelance programmer, you need to know this stuff!Even if you're already an expert and know all there is to know about virtual machines, this book is a fun read. I cannot do anything but wholeheartedly recommend this book. I've read hundreds of programming books over the years.. and this is by far the best.",
                "review/helpfulness": "11/16",
                "num_reviews": 16
            },
            {
                "review/text": "Blunden's &quot;Virtual Machine Design and Implementation in C/C++&quot; inspired me to write my own VM, and that is far more than I can say for other books. This book is so well written that it changed the way I thought and I felt enlightened. This is one of my all time favourite books - period. On *any* subject.If you're a computer engineer or are intimately familiar with computer architecture or VMs, you will probably be disappointed because you'll cover ground you're already familiar with. But for everyone else, be prepared to stay up all night reading. You WON'T be able to put this book down!Blunden starts at the very beginning of designing and specifying a virtual machine, then justifies his design choices and discusses alternatives. He presents the design and implementation of the HEC VM *System* - not just a VM. You'll go all the way here: assembler, debugger and the kitchen sink. If you're mystified at how assemblers, debuggers, compilers, abstract/virtual machines work - or even real computers and indeed operating systems, then you'll LOVE this book.Blunden covers memory management in detail early in the book, and discusses instruction set architecture in detail. He covers the HEC runtime and the way opcodes are interpreted and executed. Then he discusses the design and implementation of an assembler and debugger. HEC's compiled assembly files/object code files/executable program files are dissected and studied in detail, along with HEC's entire instruction set and its format. System interrupts are treated in detail. Interfacing with the host system and using the TCP/IP networking facilities available there is discussed and illustrated with code from the HEC VM. You could build a sophisticated VM like the Java Virtual Machine from what you'll learn in this book. Even if you don't find HEC itself very exciting, the concepts you'll learn by following the book and studying HEC will stick in your brain and inspire you when you design and write your own systems; virtual machine, operating system, assembler, debugger, or whatever.Even if VMs are only somewhat related to what your project is - such as an operating system or assembler, debugger and linker - you WILL find this book inspiring and packed with readable and useful information and insights.The title is a little misleading however - there is no C++ to speak of in this book, save for a couple of pages toward the end. (Typical dishonesty from marketing and sales types). It's all C.",
                "review/helpfulness": "10/16",
                "num_reviews": 16
            },
            {
                "review/text": "I was very dissappointed that this book does not really cover anything more than basic topics that one could get (better and more thoroughly) from a standard computer textbook.Examples: 1) no discussion of how garbage collection works and tradeoffs [just a list], 2) no discussion about alternatives for coding the main instruction execution loop, 3) no discussion of how to implement a VM that is object aware [the subjects in chapter 8 talk about how to simulate objects in HEC - not at all the same thing], 4) no practical discussion on how to implement threading, locking, simultaneous access, etc. 5) no discussion about how to implement a VM with exception handling [again, there is talk about simulating it with HEC - again, not the same thing].The discussion of multitasking exemplifies my problems with this book. Here are some quotes: \"The bottom line is that I really didn't feel like I had a good way to implement multitasking at the virtual machine level. ... The only decision that seemed to make sense was to abandon simulated multitasking and design the HEC virtual machine to execute as a single-threaded task.\"And with that, multithreading is dispatched without any help to the serious VM implementor. Similar dissmissive comments can be found regarding GUI, garbage collection, and stack machines.I'm sorry, but I do not consider \"it was too hard, so I decided not to,\" to be a valid excuse for an author.Basically, the book is a discussion of a toy project invented by the author: the HEC. Unfortunately, the HEC is strictly 1980's technology.Under no circumstance should you purchase this book to learn Java or the Java VM more thoroughly.",
                "review/helpfulness": "11/14",
                "num_reviews": 14
            },
            {
                "review/text": "If you are a beginner on computer technology, this book may provide some good information. Otherwise it is little value for a professional programmer. The book also can be much shorter. Don't know why it list all those source code. Kind of wasting paper.",
                "review/helpfulness": "9/13",
                "num_reviews": 13
            }
        ]
    }
]